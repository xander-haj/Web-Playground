{
  "button": {
    "title": "Button: The Core of Interactivity",
    "description": "The button is a fundamental interactive element in web design. It's used to trigger actions like submitting forms, opening dialogs, confirming choices, or performing an operation. Unlike links, which are for navigation, buttons are for *actions*. Using the correct HTML element (`<button>`) provides essential accessibility and browser functionality for free, such as keyboard focus and form submission capabilities.",
    "lesson": "Button Overview\n\nButton provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "modal": {
    "title": "Modal: Focusing User Attention",
    "description": "A modal (or dialog) is an overlay that appears on top of the main page content. It's used to grab the user's full attention for a critical task, message, or piece of information without navigating away from the current page. The modern approach uses the native `<dialog>` element, which provides built-in accessibility features like focus trapping and an 'Escape' key binding.",
    "lesson": "Modal Overview\n\nModal provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "accordion": {
    "title": "Accordion: Managing Content Visibility",
    "description": "An accordion is a UI element that allows users to show and hide sections of content. It consists of a vertically stacked list of headers that can be clicked to reveal or hide associated content panels. Accordions are ideal for FAQs, product features, or any scenario where you need to present a lot of information in a compact space without overwhelming the user.",
    "lesson": "Accordion Overview\n\nAccordion provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "headings": {
    "title": "Headings: Structuring Content Hierarchy",
    "description": "HTML headings (h1-h6) are used to create a clear hierarchy of content on web pages. They help users understand the structure and importance of different sections, while also providing crucial semantic information for screen readers and search engines. Proper heading structure is fundamental to web accessibility and SEO.",
    "lesson": "Headings Overview\n\nHeadings provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "paragraphs": {
    "title": "Paragraphs: The Foundation of Text Content",
    "description": "The paragraph element (`<p>`) is the most common way to display blocks of text content on web pages. Paragraphs provide semantic meaning to text blocks and allow for consistent styling and spacing. Understanding how to properly structure and style paragraphs is essential for readable, accessible web content.",
    "lesson": "Paragraphs Overview\n\nParagraphs provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "links": {
    "title": "Links: Connecting the Web",
    "description": "Anchor elements (`<a>`) are what make the web truly interconnected. They allow users to navigate between pages, sections, and external resources. Proper link implementation involves semantic HTML, clear visual indication, and accessibility considerations to ensure all users can navigate effectively.",
    "lesson": "Links Overview\n\nLinks provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "lists": {
    "title": "Lists: Organizing Information",
    "description": "HTML lists (`<ul>`, `<ol>`, `<dl>`) are powerful tools for organizing and presenting related information. They provide semantic structure that helps users and assistive technologies understand content relationships. Lists are essential for navigation menus, feature lists, step-by-step instructions, and data organization.",
    "lesson": "Lists Overview\n\nLists provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "table": {
    "title": "Table: Displaying Tabular Data",
    "description": "HTML tables (`<table>`) are designed specifically for displaying tabular data - information that has a relationship between rows and columns. Proper table structure with headers, captions, and semantic markup ensures data is accessible and meaningful to all users, including those using screen readers.",
    "lesson": "Table Overview\n\nTable provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "form": {
    "title": "Form: Collecting User Input",
    "description": "HTML forms (`<form>`) are the primary method for collecting user input on web pages. They encompass various input types, validation methods, and submission processes. Well-structured forms with proper labels, fieldsets, and error handling create better user experiences and ensure accessibility compliance.",
    "lesson": "Form Overview\n\nForm provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "label": {
    "title": "Label: Enhancing Form Accessibility",
    "description": "Form labels (`<label>`) are crucial for creating accessible forms. They provide clear descriptions of form controls and create programmatic relationships that assistive technologies can understand. Proper labeling is not just about accessibility - it also improves usability by making form controls easier to interact with.",
    "lesson": "Label Overview\n\nLabel provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "input": {
    "title": "Input: Capturing User Data",
    "description": "Input elements (`<input>`) are the workhorses of web forms, capable of collecting various types of user data through different input types. From text and email to dates and files, input elements can be customized with attributes for validation, formatting, and enhanced user experience.",
    "lesson": "Input Overview\n\nInput provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "textarea": {
    "title": "Textarea: Multi-line Text Input",
    "description": "The textarea element (`<textarea>`) is designed for collecting longer, multi-line text input from users. Unlike single-line input elements, textareas can expand to accommodate larger amounts of text and provide users with a clear visual indication of the expected input length.",
    "lesson": "Textarea Overview\n\nTextarea provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "select": {
    "title": "Select: Dropdown Menus for Options",
    "description": "Select elements (`<select>`) create dropdown menus that allow users to choose from predefined options. They're ideal for situations where you want to limit user choices while saving space on the interface. Proper select implementation includes accessibility features and clear option labeling.",
    "lesson": "Select Overview\n\nSelect provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "tabs": {
    "title": "Tabs: Organizing Content into Panels",
    "description": "Tab interfaces allow users to switch between different panels of content within the same space. They're excellent for organizing related information without overwhelming users with too much content at once. Accessible tab implementation requires proper ARIA attributes and keyboard navigation support.",
    "lesson": "Tabs Overview\n\nTabs provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "tooltip": {
    "title": "Tooltip: Contextual Information",
    "description": "Tooltips provide additional context or information when users hover over or focus on an element. They're useful for explaining functionality, providing help text, or showing supplementary information without cluttering the main interface. Accessible tooltips work with both mouse and keyboard interactions.",
    "lesson": "Tooltip Overview\n\nTooltip provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "dropdown": {
    "title": "Dropdown: Expandable Menu Interface",
    "description": "Dropdown menus provide a space-efficient way to present multiple options or actions. They can be triggered by buttons, links, or other interactive elements and typically contain navigation links, actions, or form controls. Proper dropdown implementation includes keyboard navigation and proper focus management.",
    "lesson": "Dropdown Overview\n\nDropdown provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "checkbox": {
    "title": "Checkbox: Ticking the Boxes",
    "description": "Checkboxes allow users to select one or more options from a set. They are ideal for settings, terms of service agreements, or multi-choice questions. Styling checkboxes can be tricky, often requiring custom CSS to create a consistent look across browsers while maintaining accessibility.",
    "lesson": "Checkbox Overview\n\nCheckbox provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "radio_group": {
    "title": "Radio Group: Selecting One from Many",
    "description": "Radio buttons are used when a user must select only one option from a list of two or more mutually exclusive choices. Grouping them within a `<fieldset>` with a `<legend>` is crucial for accessibility, as it programmatically links the choices together.",
    "lesson": "Radio Group Overview\n\nRadio Group provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "toggle_switch": {
    "title": "Toggle Switch: On or Off",
    "description": "A toggle switch is a visually intuitive way to represent a binary state, like on/off or enabled/disabled. It's typically built on top of a standard checkbox input, using CSS to create the switch-like appearance. This ensures it's accessible and functional even without CSS.",
    "lesson": "Toggle Switch Overview\n\nToggle Switch provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "range_slider": {
    "title": "Range Slider: Selecting a Value",
    "description": "Range sliders allow users to select a value from a continuous or discrete range. They are perfect for adjusting settings like volume, brightness, or price filters. Styling sliders consistently across browsers requires specific CSS selectors for the track and thumb.",
    "lesson": "Range Slider Overview\n\nRange Slider provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "file_upload": {
    "title": "File Upload: Adding Attachments",
    "description": "The file upload component allows users to select local files for submission. A modern implementation includes a drag-and-drop area for better user experience and a preview area to show the selected file(s) before uploading.",
    "lesson": "File Upload Overview\n\nFile Upload provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "date_picker": {
    "title": "Date Picker: Choosing a Date",
    "description": "Modern browsers have native date, time, and datetime pickers built into their `<input>` elements. Using these native pickers (`type=\"date\"`, `type=\"time\"`, `type=\"datetime-local\"`) is often the most accessible and mobile-friendly approach, though custom styling is limited.",
    "lesson": "Date Picker Overview\n\nDate Picker provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "search_input": {
    "title": "Search Input: Finding Information",
    "description": "A search input often includes advanced features like an autocomplete or suggestions dropdown. This helps guide users to valid results, reduces typing errors, and improves the overall search experience. JavaScript is essential for fetching and displaying these suggestions.",
    "lesson": "Search Input Overview\n\nSearch Input provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "multi_select_dropdown": {
    "title": "Multi-select: Choosing Many",
    "description": "When a native `<select multiple>` is too cumbersome, a custom multi-select dropdown provides a better user experience. It combines the compactness of a dropdown with the multi-choice capability of checkboxes, making it easy to select multiple items from a long list.",
    "lesson": "Multi Select Dropdown Overview\n\nMulti Select Dropdown provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "card": {
    "title": "Card: Versatile Content Containers",
    "description": "Cards are flexible containers used to group related content and actions. They are a cornerstone of modern UI design, commonly used in dashboards, galleries, and feeds to present information in a digestible, organized manner. Their modular nature makes them ideal for responsive layouts.",
    "lesson": "Card Overview\n\nCard provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "badge": {
    "title": "Badge: Small Status Descriptors",
    "description": "Badges (also known as pills or tags) are small, inline elements used to label, categorize, or highlight information. They are perfect for status indicators (e.g., 'Active', 'New'), counts, or keywords, providing quick visual context without taking up much space.",
    "lesson": "Badge Overview\n\nBadge provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nBadge Specifics:\n- Keep badges concise; they aid scanning and status indication.\n- Use color plus text — color alone is not accessible for conveying meaning.\n"
  },
  "avatar": {
    "title": "Avatar: Representing Users",
    "description": "An avatar is a graphical representation of a user, typically a profile picture or initials. Avatars are commonly used in social applications, comment sections, and user menus to provide a personal touch and quick visual identification. They can be circular or square and often include a status indicator.",
    "lesson": "Avatar Overview\n\nAvatar provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nAvatar Specifics:\n- Use `<img>` with descriptive `alt` text; if purely decorative, set `alt=\"\"`.\n- Offer shape variants (circle/rounded/square) via classes, not extra markup.\n- Constrain size with a container and `object-fit: cover` for reliable cropping.\n"
  },
  "progress_bar": {
    "title": "Progress Bar: Visualizing Completion",
    "description": "Progress bars provide visual feedback on the status of a process, such as a download, upload, or multi-step form completion. A 'determinate' bar shows how much of a task is complete, while an 'indeterminate' bar shows that an operation is ongoing but its completion time is unknown.",
    "lesson": "Progress Bar Overview\n\nProgress Bar provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nProgress Bar Specifics:\n- For determinate progress, include `aria-valuemin`, `aria-valuemax`, and `aria-valuenow`.\n- For indeterminate, omit `aria-valuenow` and animate the fill segment.\n"
  },
  "stat_block": {
    "title": "Stat Block: Highlighting Key Metrics",
    "description": "A stat block or Key Performance Indicator (KPI) display is used to draw attention to a single, important piece of data. It prominently features a number or metric, a descriptive label, and often includes context like a comparison to a previous period.",
    "lesson": "Stat Block Overview\n\nStat Block provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "timeline": {
    "title": "Timeline: Sequencing Events",
    "description": "A timeline or activity feed is used to display a list of events in chronological order. It's an effective way to represent history, track updates, or show a sequence of steps. Timelines are commonly found in project management tools, social media feeds, and order tracking pages.",
    "lesson": "Timeline Overview\n\nTimeline provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nTimeline Specifics:\n- Prefer lists (`<ol>`/`<ul>`) and ensure chronological order is clear.\n- Include `<time>` elements for machine-readable dates.\n"
  },
  "toast": {
    "title": "Toast: Providing Brief Notifications",
    "description": "Toast notifications are small, non-modal pop-up messages used to provide brief, timely feedback on an action. They appear for a short duration and then disappear automatically without disrupting the user's workflow. They are ideal for confirming actions like 'File saved' or 'Message sent'.",
    "lesson": "Toast Overview\n\nToast provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nToast Specifics:\n- Use `aria-live=\"polite\"` for non-critical info; use dialogs for critical alerts.\n- Auto-dismiss with a clear visible countdown or leave persistent until user dismisses.\n"
  },
  "breadcrumbs": {
    "title": "Breadcrumbs: Navigational Aid",
    "description": "Breadcrumbs are a secondary navigation scheme that reveals the user's location in a website or web app. They provide a trail of links back to each previous page the user navigated through to get to the current page, helping users understand and navigate the site's hierarchy.",
    "lesson": "Breadcrumbs Overview\n\nBreadcrumbs provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nBreadcrumbs Specifics:\n- Structure as a `<nav aria-label=\"breadcrumb\">` containing an ordered list.\n- Mark the current page with `aria-current=\"page\"`.\n- Use separators via CSS rather than literal characters in the markup for cleaner semantics.\n"
  },
  "sidebar": {
    "title": "Sidebar: Collapsible Navigation",
    "description": "Sidebar navigation provides a persistent menu of links and options, typically on the left or right side of the screen. A collapsible sidebar is a space-saving pattern that can be hidden and shown by the user, making it ideal for applications with many navigation items or for use on smaller screens.",
    "lesson": "Sidebar Overview\n\nSidebar provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n"
  },
  "pagination": {
    "title": "Pagination: Navigating Content Sets",
    "description": "Pagination is used to divide a large set of content (like search results, articles, or product listings) into separate pages. It allows users to navigate through the content page by page, which is more manageable than loading all content at once.",
    "lesson": "Pagination Overview\n\nPagination provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nPagination Specifics:\n- Wrap links in `<nav aria-label=\"Page navigation\">` for context.\n- Indicate current page with `aria-current=\"page\"` and a visible style.\n"
  },
  "stepper": {
    "title": "Stepper: Guiding Multi-Step Processes",
    "description": "A stepper, or wizard, guides users through a process that is broken down into a series of logical steps. It shows the user's progress through the sequence, indicating which steps are complete, which is active, and which are yet to be done. It's commonly used for checkout processes and complex form submissions.",
    "lesson": "Stepper Overview\n\nStepper provides a reusable pattern that is semantic, accessible, and adaptable to your design system. Use progressive enhancement: start with correct HTML, layer CSS for appearance, and add JavaScript only for behaviors that HTML alone cannot provide.\n\nAccessibility Checklist:\n- Use appropriate roles and ARIA attributes only when native semantics are insufficient.\n- Ensure full keyboard support (Tab, Shift+Tab, Enter/Space, Arrow keys as relevant).\n- Maintain sufficient color contrast and visible focus states.\n- Announce dynamic changes with ARIA live regions where necessary.\n\nImplementation Notes:\n- Keep markup minimal and meaningful.\n- Isolate styles behind component classes and CSS variables for easy theming.\n- Avoid inline JavaScript. Prefer unobtrusive handlers loaded once per page.\n\nTesting Tips:\n- Navigate the component using only the keyboard.\n- Test with a screen reader and high-contrast mode.\n- Verify behavior without JavaScript to confirm graceful degradation.\n\nStepper Specifics:\n- Represent steps as an ordered list; communicate progress state visually and via text.\n- Provide Next/Previous buttons and maintain focus order.\n"
  }
}