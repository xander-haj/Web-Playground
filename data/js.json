{
  "button": {
    "title": "Handling User Actions",
    "description": "JavaScript brings buttons to life by defining what happens when they are clicked. The modern, standard approach is to use `addEventListener` to attach a 'click' event listener. This cleanly separates your behavior (JavaScript) from your structure (HTML), which is a core principle of modern web development.",
    "code": "const myButton = document.querySelector('.btn');\\\\n\\\\nmyButton.addEventListener('click', () => {\\\\n  // The action to perform when the button is clicked.\\\\n  // For example, show an alert or update the page.\\\\n  alert('Button was clicked!');\\\\n});"
  },
  "modal": {
    "title": "Controlling the Modal",
    "description": "JavaScript is used to control the modal's visibility. The `<dialog>` element has simple, built-in methods that make this easy:\\\\n- `.showModal()`: Opens the dialog as a modal. This creates the backdrop, centers the dialog, and traps focus inside it.\\\\n- `.close()`: Closes the dialog. The browser automatically handles returning focus to the element that opened it.",
    "code": "const dialog = document.getElementById('example-modal');\\\\nconst openBtn = document.getElementById('open-modal-btn');\\\\nconst closeBtn = document.getElementById('close-modal-btn');\\\\n\\\\n// Open the modal\\\\nopenBtn.addEventListener('click', () => {\\\\n  dialog.showModal();\\\\n});\\\\n\\\\n// Close the modal\\\\ncloseBtn.addEventListener('click', () => {\\\\n  dialog.close();\\\\n});\\\\n\\\\n// Optional: Close when clicking the backdrop\\\\ndialog.addEventListener('click', (e) => {\\\\n    if (e.target === dialog) {\\\\n        dialog.close();\\\\n    }\\\\n});"
  },
  "accordion": {
    "title": "Toggling State with JavaScript",
    "description": "The JavaScript logic handles user interaction. When an accordion button is clicked, the script toggles the state. It changes the `aria-expanded` attribute on the button from \\\\\\\"true\\\\\\\" to \\\\\\\"false\\\\\\\" (or vice-versa) and toggles the `hidden` attribute on the corresponding panel. The entire logic is centered around manipulating these key attributes, ensuring the component's state is always clear to assistive technologies.",
    "code": "const accordionButtons = document.querySelectorAll('.accordion-button');\\\\n\\\\naccordionButtons.forEach(button => {\\\\n  button.addEventListener('click', () => {\\\\n    // Check the current state\\\\n    const isExpanded = button.getAttribute('aria-expanded') === 'true';\\\\n    const panel = document.getElementById(button.getAttribute('aria-controls'));\\\\n\\\\n    // Toggle the attributes\\\\n    button.setAttribute('aria-expanded', !isExpanded);\\\\n    panel.hidden = isExpanded;\\\\n  });\\\\n});"
  },
  "headings": {
    "title": "Dynamic Heading Management",
    "description": "JavaScript can be used to dynamically create table of contents, smooth scrolling navigation, and automatic heading numbering. These features enhance the user experience while maintaining semantic structure.",
    "code": "<!-- Generate table of contents from headings -->\\\\nfunction generateTOC() {\\\\n  const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\\\\n  const toc = document.getElementById('table-of-contents');\\\\n  \\\\n  headings.forEach((heading, index) => {\\\\n    // Create ID if not exists\\\\n    if (!heading.id) {\\\\n      heading.id = `heading-${index}`;\\\\n    }\\\\n    \\\\n    // Create TOC link\\\\n    const link = document.createElement('a');\\\\n    link.href = `#${heading.id}`;\\\\n    link.textContent = heading.textContent;\\\\n    link.className = `toc-${heading.tagName.toLowerCase()}`;\\\\n    \\\\n    toc.appendChild(link);\\\\n  });\\\\n}\\\\n\\\\n// Smooth scroll to heading\\\\nfunction smoothScrollToHeading(id) {\\\\n  const element = document.getElementById(id);\\\\n  if (element) {\\\\n    element.scrollIntoView({ behavior: 'smooth' });\\\\n  }\\\\n}\\\\n\\\\n// Auto-number headings\\\\nfunction autoNumberHeadings() {\\\\n  const headings = document.querySelectorAll('h2, h3, h4');\\\\n  const counters = { h2: 0, h3: 0, h4: 0 };\\\\n  \\\\n  headings.forEach(heading => {\\\\n    const level = heading.tagName.toLowerCase();\\\\n    \\\\n    if (level === 'h2') {\\\\n      counters.h2++;\\\\n      counters.h3 = 0;\\\\n      counters.h4 = 0;\\\\n      heading.textContent = `${counters.h2}. ${heading.textContent}`;\\\\n    } else if (level === 'h3') {\\\\n      counters.h3++;\\\\n      counters.h4 = 0;\\\\n      heading.textContent = `${counters.h2}.${counters.h3}. ${heading.textContent}`;\\\\n    } else if (level === 'h4') {\\\\n      counters.h4++;\\\\n      heading.textContent = `${counters.h2}.${counters.h3}.${counters.h4}. ${heading.textContent}`;\\\\n    }\\\\n  });\\\\n}\\\\n\\\\n// Initialize TOC and numbering\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  generateTOC();\\\\n  autoNumberHeadings();\\\\n});"
  },
  "paragraphs": {
    "title": "Text Manipulation and Reading Enhancement",
    "description": "JavaScript can enhance paragraph readability through features like reading time estimation, text highlighting, and dynamic text sizing. These features improve user experience without changing the semantic structure.",
    "code": "<!-- Calculate reading time for paragraphs -->\\\\nfunction calculateReadingTime() {\\\\n  const paragraphs = document.querySelectorAll('p');\\\\n  const wordsPerMinute = 200;\\\\n  \\\\n  paragraphs.forEach(paragraph => {\\\\n    const text = paragraph.textContent;\\\\n    const wordCount = text.split(/\\\\\\\\s+/).length;\\\\n    const readingTime = Math.ceil(wordCount / wordsPerMinute);\\\\n    \\\\n    // Add reading time indicator\\\\n    const indicator = document.createElement('small');\\\\n    indicator.className = 'reading-time';\\\\n    indicator.textContent = `${readingTime} min read`;\\\\n    paragraph.appendChild(indicator);\\\\n  });\\\\n}\\\\n\\\\n// Highlight text search results\\\\nfunction highlightText(searchTerm) {\\\\n  const paragraphs = document.querySelectorAll('p');\\\\n  const regex = new RegExp(`(${searchTerm})`, 'gi');\\\\n  \\\\n  paragraphs.forEach(paragraph => {\\\\n    const originalText = paragraph.innerHTML;\\\\n    const highlightedText = originalText.replace(regex, '<mark>$1</mark>');\\\\n    paragraph.innerHTML = highlightedText;\\\\n  });\\\\n}\\\\n\\\\n// Dynamic text sizing\\\\nfunction adjustTextSize(factor) {\\\\n  const paragraphs = document.querySelectorAll('p');\\\\n  \\\\n  paragraphs.forEach(paragraph => {\\\\n    const currentSize = parseFloat(getComputedStyle(paragraph).fontSize);\\\\n    paragraph.style.fontSize = `${currentSize * factor}px`;\\\\n  });\\\\n}\\\\n\\\\n// Text-to-speech for accessibility\\\\nfunction readParagraph(paragraph) {\\\\n  if ('speechSynthesis' in window) {\\\\n    const utterance = new SpeechSynthesisUtterance(paragraph.textContent);\\\\n    utterance.rate = 0.8;\\\\n    utterance.pitch = 1;\\\\n    speechSynthesis.speak(utterance);\\\\n  }\\\\n}\\\\n\\\\n// Add click handlers for text enhancement\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  calculateReadingTime();\\\\n  \\\\n  // Add double-click to read paragraphs\\\\n  document.querySelectorAll('p').forEach(paragraph => {\\\\n    paragraph.addEventListener('dblclick', () => {\\\\n      readParagraph(paragraph);\\\\n    });\\\\n  });\\\\n});"
  },
  "links": {
    "title": "Enhanced Link Behavior",
    "description": "JavaScript can enhance link functionality with features like external link indicators, smooth scrolling for anchor links, link tracking, and enhanced accessibility. These improvements maintain the semantic nature of links while adding useful functionality.",
    "code": "<!-- Enhanced external link handling -->\\\\nfunction enhanceExternalLinks() {\\\\n  const externalLinks = document.querySelectorAll('a[href^=\\\\\\\"http\\\\\\\"]');\\\\n  \\\\n  externalLinks.forEach(link => {\\\\n    // Add external indicator\\\\n    if (!link.querySelector('.external-icon')) {\\\\n      const icon = document.createElement('span');\\\\n      icon.className = 'external-icon';\\\\n      icon.setAttribute('aria-hidden', 'true');\\\\n      icon.textContent = ' ↗';\\\\n      link.appendChild(icon);\\\\n    }\\\\n    \\\\n    // Add security attributes\\\\n    link.setAttribute('target', '_blank');\\\\n    link.setAttribute('rel', 'noopener noreferrer');\\\\n    \\\\n    // Add click tracking\\\\n    link.addEventListener('click', (e) => {\\\\n      console.log(`External link clicked: ${link.href}`);\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Smooth scrolling for anchor links\\\\nfunction enableSmoothScrolling() {\\\\n  const anchorLinks = document.querySelectorAll('a[href^=\\\\\\\"#\\\\\\\"]');\\\\n  \\\\n  anchorLinks.forEach(link => {\\\\n    link.addEventListener('click', (e) => {\\\\n      e.preventDefault();\\\\n      const targetId = link.getAttribute('href').substring(1);\\\\n      const targetElement = document.getElementById(targetId);\\\\n      \\\\n      if (targetElement) {\\\\n        targetElement.scrollIntoView({\\\\n          behavior: 'smooth',\\\\n          block: 'start'\\\\n        });\\\\n        \\\\n        // Update URL without jumping\\\\n        history.pushState(null, null, `#${targetId}`);\\\\n      }\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Link preview on hover\\\\nfunction addLinkPreviews() {\\\\n  const links = document.querySelectorAll('a[href^=\\\\\\\"http\\\\\\\"]');\\\\n  \\\\n  links.forEach(link => {\\\\n    link.addEventListener('mouseenter', (e) => {\\\\n      const preview = document.createElement('div');\\\\n      preview.className = 'link-preview';\\\\n      preview.textContent = `Preview: ${link.href}`;\\\\n      preview.style.position = 'absolute';\\\\n      preview.style.background = '#333';\\\\n      preview.style.color = 'white';\\\\n      preview.style.padding = '0.5rem';\\\\n      preview.style.borderRadius = '4px';\\\\n      preview.style.fontSize = '0.8rem';\\\\n      preview.style.zIndex = '1000';\\\\n      preview.style.top = `${e.pageY + 10}px`;\\\\n      preview.style.left = `${e.pageX + 10}px`;\\\\n      \\\\n      document.body.appendChild(preview);\\\\n      link.setAttribute('data-preview-id', 'active');\\\\n    });\\\\n    \\\\n    link.addEventListener('mouseleave', () => {\\\\n      const preview = document.querySelector('.link-preview');\\\\n      if (preview && link.getAttribute('data-preview-id') === 'active') {\\\\n        preview.remove();\\\\n        link.removeAttribute('data-preview-id');\\\\n      }\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Initialize link enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  enhanceExternalLinks();\\\\n  enableSmoothScrolling();\\\\n  addLinkPreviews();\\\\n});\\\\n\\\\n// Link validation\\\\nfunction validateLinks() {\\\\n  const links = document.querySelectorAll('a[href]');\\\\n  \\\\n  links.forEach(async (link) => {\\\\n    if (link.href.startsWith('http')) {\\\\n      try {\\\\n        const response = await fetch(link.href, { method: 'HEAD' });\\\\n        if (!response.ok) {\\\\n          link.classList.add('broken-link');\\\\n          link.title = 'This link may be broken';\\\\n        }\\\\n      } catch (error) {\\\\n        link.classList.add('broken-link');\\\\n        link.title = 'This link may be broken';\\\\n      }\\\\n    }\\\\n  });\\\\n}"
  },
  "lists": {
    "title": "Interactive List Features",
    "description": "JavaScript can add interactivity to lists through features like sorting, filtering, drag-and-drop reordering, and dynamic list management. These enhancements maintain the semantic structure while adding powerful functionality.",
    "code": "<!-- Sortable list functionality -->\\\\nclass SortableList {\\\\n  constructor(listElement) {\\\\n    this.list = listElement;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.list.addEventListener('click', (e) => {\\\\n      if (e.target.classList.contains('sort-btn')) {\\\\n        this.sortList(e.target.dataset.sortType);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  sortList(sortType) {\\\\n    const items = Array.from(this.list.querySelectorAll('li'));\\\\n    \\\\n    items.sort((a, b) => {\\\\n      const aText = a.textContent.trim();\\\\n      const bText = b.textContent.trim();\\\\n      \\\\n      if (sortType === 'alpha') {\\\\n        return aText.localeCompare(bText);\\\\n      } else if (sortType === 'alpha-desc') {\\\\n        return bText.localeCompare(aText);\\\\n      }\\\\n      return 0;\\\\n    });\\\\n    \\\\n    // Clear and rebuild list\\\\n    this.list.innerHTML = '';\\\\n    items.forEach(item => this.list.appendChild(item));\\\\n  }\\\\n}\\\\n\\\\n// Filterable list\\\\nclass FilterableList {\\\\n  constructor(listElement, filterInput) {\\\\n    this.list = listElement;\\\\n    this.filter = filterInput;\\\\n    this.items = Array.from(this.list.querySelectorAll('li'));\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.filter.addEventListener('input', (e) => {\\\\n      this.filterItems(e.target.value);\\\\n    });\\\\n  }\\\\n  \\\\n  filterItems(searchTerm) {\\\\n    const term = searchTerm.toLowerCase();\\\\n    \\\\n    this.items.forEach(item => {\\\\n      const text = item.textContent.toLowerCase();\\\\n      const matches = text.includes(term);\\\\n      \\\\n      item.style.display = matches ? 'block' : 'none';\\\\n      \\\\n      if (matches && term) {\\\\n        this.highlightMatch(item, term);\\\\n      } else {\\\\n        this.removeHighlight(item);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  highlightMatch(item, term) {\\\\n    const text = item.textContent;\\\\n    const regex = new RegExp(`(${term})`, 'gi');\\\\n    item.innerHTML = text.replace(regex, '<mark>$1</mark>');\\\\n  }\\\\n  \\\\n  removeHighlight(item) {\\\\n    const text = item.textContent;\\\\n    item.innerHTML = text;\\\\n  }\\\\n}\\\\n\\\\n// Dynamic list management\\\\nclass DynamicList {\\\\n  constructor(listElement) {\\\\n    this.list = listElement;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.addControls();\\\\n    this.attachEventListeners();\\\\n  }\\\\n  \\\\n  addControls() {\\\\n    const controls = document.createElement('div');\\\\n    controls.className = 'list-controls';\\\\n    controls.innerHTML = `\\\\n      <input type=\\\\\\\"text\\\\\\\" placeholder=\\\\\\\"Add new item\\\\\\\" class=\\\\\\\"new-item-input\\\\\\\">\\\\n      <button type=\\\\\\\"button\\\\\\\" class=\\\\\\\"add-item-btn\\\\\\\">Add Item</button>\\\\n    `;\\\\n    \\\\n    this.list.parentNode.insertBefore(controls, this.list);\\\\n  }\\\\n  \\\\n  attachEventListeners() {\\\\n    const addBtn = this.list.parentNode.querySelector('.add-item-btn');\\\\n    const input = this.list.parentNode.querySelector('.new-item-input');\\\\n    \\\\n    addBtn.addEventListener('click', () => {\\\\n      this.addItem(input.value);\\\\n      input.value = '';\\\\n    });\\\\n    \\\\n    input.addEventListener('keypress', (e) => {\\\\n      if (e.key === 'Enter') {\\\\n        this.addItem(input.value);\\\\n        input.value = '';\\\\n      }\\\\n    });\\\\n    \\\\n    this.list.addEventListener('click', (e) => {\\\\n      if (e.target.classList.contains('remove-btn')) {\\\\n        this.removeItem(e.target.closest('li'));\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  addItem(text) {\\\\n    if (!text.trim()) return;\\\\n    \\\\n    const item = document.createElement('li');\\\\n    item.innerHTML = `\\\\n      ${text}\\\\n      <button type=\\\\\\\"button\\\\\\\" class=\\\\\\\"remove-btn\\\\\\\">×</button>\\\\n    `;\\\\n    \\\\n    this.list.appendChild(item);\\\\n  }\\\\n  \\\\n  removeItem(item) {\\\\n    item.remove();\\\\n  }\\\\n}\\\\n\\\\n// Initialize list enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  // Initialize sortable lists\\\\n  document.querySelectorAll('.sortable-list').forEach(list => {\\\\n    new SortableList(list);\\\\n  });\\\\n  \\\\n  // Initialize filterable lists\\\\n  document.querySelectorAll('.filterable-list').forEach(list => {\\\\n    const filter = list.parentNode.querySelector('.list-filter');\\\\n    if (filter) {\\\\n      new FilterableList(list, filter);\\\\n    }\\\\n  });\\\\n  \\\\n  // Initialize dynamic lists\\\\n  document.querySelectorAll('.dynamic-list').forEach(list => {\\\\n    new DynamicList(list);\\\\n  });\\\\n});"
  },
  "table": {
    "title": "Interactive Table Features",
    "description": "JavaScript can enhance tables with sorting, filtering, pagination, and responsive behavior. These features improve usability for large datasets while maintaining the semantic table structure and accessibility.",
    "code": "<!-- Enhanced table functionality -->\\\\nclass InteractiveTable {\\\\n  constructor(tableElement) {\\\\n    this.table = tableElement;\\\\n    this.tbody = this.table.querySelector('tbody');\\\\n    this.thead = this.table.querySelector('thead');\\\\n    this.rows = Array.from(this.tbody.querySelectorAll('tr'));\\\\n    this.currentSort = { column: -1, direction: 'asc' };\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.addSortingToHeaders();\\\\n    this.makeResponsive();\\\\n    this.addRowHover();\\\\n  }\\\\n  \\\\n  addSortingToHeaders() {\\\\n    const headers = this.thead.querySelectorAll('th');\\\\n    \\\\n    headers.forEach((header, index) => {\\\\n      if (header.hasAttribute('data-sortable')) {\\\\n        header.style.cursor = 'pointer';\\\\n        header.innerHTML += ' <span class=\\\\\\\"sort-indicator\\\\\\\">↕</span>';\\\\n        \\\\n        header.addEventListener('click', () => {\\\\n          this.sortTable(index);\\\\n        });\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  sortTable(columnIndex) {\\\\n    const isAscending = this.currentSort.column !== columnIndex || this.currentSort.direction === 'desc';\\\\n    const direction = isAscending ? 'asc' : 'desc';\\\\n    \\\\n    this.rows.sort((a, b) => {\\\\n      const aValue = a.cells[columnIndex].textContent.trim();\\\\n      const bValue = b.cells[columnIndex].textContent.trim();\\\\n      \\\\n      // Try to parse as numbers\\\\n      const aNum = parseFloat(aValue);\\\\n      const bNum = parseFloat(bValue);\\\\n      \\\\n      let comparison = 0;\\\\n      \\\\n      if (!isNaN(aNum) && !isNaN(bNum)) {\\\\n        // Numeric comparison\\\\n        comparison = aNum - bNum;\\\\n      } else {\\\\n        // String comparison\\\\n        comparison = aValue.localeCompare(bValue);\\\\n      }\\\\n      \\\\n      return isAscending ? comparison : -comparison;\\\\n    });\\\\n    \\\\n    // Update DOM\\\\n    this.tbody.innerHTML = '';\\\\n    this.rows.forEach(row => this.tbody.appendChild(row));\\\\n    \\\\n    // Update sort indicators\\\\n    this.updateSortIndicators(columnIndex, direction);\\\\n    \\\\n    this.currentSort = { column: columnIndex, direction };\\\\n  }\\\\n  \\\\n  updateSortIndicators(activeColumn, direction) {\\\\n    const headers = this.thead.querySelectorAll('th');\\\\n    \\\\n    headers.forEach((header, index) => {\\\\n      const indicator = header.querySelector('.sort-indicator');\\\\n      if (indicator) {\\\\n        if (index === activeColumn) {\\\\n          indicator.textContent = direction === 'asc' ? '↑' : '↓';\\\\n        } else {\\\\n          indicator.textContent = '↕';\\\\n        }\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  makeResponsive() {\\\\n    if (window.innerWidth < 768) {\\\\n      this.table.classList.add('responsive-table');\\\\n    }\\\\n    \\\\n    window.addEventListener('resize', () => {\\\\n      if (window.innerWidth < 768) {\\\\n        this.table.classList.add('responsive-table');\\\\n      } else {\\\\n        this.table.classList.remove('responsive-table');\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  addRowHover() {\\\\n    this.rows.forEach(row => {\\\\n      row.addEventListener('click', () => {\\\\n        this.rows.forEach(r => r.classList.remove('selected'));\\\\n        row.classList.add('selected');\\\\n      });\\\\n    });\\\\n  }\\\\n}\\\\n\\\\n// Table filtering\\\\nclass TableFilter {\\\\n  constructor(table, filterInput) {\\\\n    this.table = table;\\\\n    this.filter = filterInput;\\\\n    this.rows = Array.from(table.querySelectorAll('tbody tr'));\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.filter.addEventListener('input', (e) => {\\\\n      this.filterRows(e.target.value);\\\\n    });\\\\n  }\\\\n  \\\\n  filterRows(searchTerm) {\\\\n    const term = searchTerm.toLowerCase();\\\\n    \\\\n    this.rows.forEach(row => {\\\\n      const text = row.textContent.toLowerCase();\\\\n      const matches = text.includes(term);\\\\n      row.style.display = matches ? '' : 'none';\\\\n    });\\\\n  }\\\\n}\\\\n\\\\n// Initialize table enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  document.querySelectorAll('table').forEach(table => {\\\\n    new InteractiveTable(table);\\\\n    \\\\n    const filter = document.querySelector(`[data-table-filter=\\\\\\\"${table.id}\\\\\\\"]`);\\\\n    if (filter) {\\\\n      new TableFilter(table, filter);\\\\n    }\\\\n  });\\\\n});"
  },
  "form": {
    "title": "Form Validation and Enhancement",
    "description": "JavaScript enhances forms with real-time validation, better user experience, and dynamic behavior. This includes client-side validation, form submission handling, and progressive enhancement while maintaining accessibility.",
    "code": "<!-- Enhanced form validation and handling -->\\\\nclass FormValidator {\\\\n  constructor(form) {\\\\n    this.form = form;\\\\n    this.fields = Array.from(form.querySelectorAll('input, textarea, select'));\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.attachEventListeners();\\\\n    this.form.addEventListener('submit', (e) => this.handleSubmit(e));\\\\n  }\\\\n  \\\\n  attachEventListeners() {\\\\n    this.fields.forEach(field => {\\\\n      field.addEventListener('blur', () => this.validateField(field));\\\\n      field.addEventListener('input', () => this.clearError(field));\\\\n    });\\\\n  }\\\\n  \\\\n  validateField(field) {\\\\n    const value = field.value.trim();\\\\n    const type = field.type;\\\\n    const required = field.hasAttribute('required');\\\\n    \\\\n    let isValid = true;\\\\n    let errorMessage = '';\\\\n    \\\\n    // Required validation\\\\n    if (required && !value) {\\\\n      isValid = false;\\\\n      errorMessage = 'This field is required';\\\\n    }\\\\n    \\\\n    // Type-specific validation\\\\n    if (value && type === 'email') {\\\\n      const emailRegex = new RegExp('^[^\\\\\\\\\\\\\\\\s@]+@[^\\\\\\\\\\\\\\\\s@]+\\\\\\\\\\\\\\\\.[^\\\\\\\\\\\\\\\\s@]+$');\\\\n      if (!emailRegex.test(value)) {\\\\n        isValid = false;\\\\n        errorMessage = 'Please enter a valid email address';\\\\n      }\\\\n    }\\\\n    \\\\n    if (value && type === 'url') {\\\\n      const urlRegex = new RegExp('^https?:\\\\\\\\\\\\\\\\/\\\\\\\\\\\\\\\\/.+');\\\\n      if (!urlRegex.test(value)) {\\\\n        isValid = false;\\\\n        errorMessage = 'Please enter a valid URL';\\\\n      }\\\\n    }\\\\n    \\\\n    // Length validation\\\\n    const minLength = field.getAttribute('minlength');\\\\n    if (value && minLength && value.length < parseInt(minLength)) {\\\\n      isValid = false;\\\\n      errorMessage = `Minimum ${minLength} characters required`;\\\\n    }\\\\n    \\\\n    this.setFieldState(field, isValid, errorMessage);\\\\n    return isValid;\\\\n  }\\\\n  \\\\n  setFieldState(field, isValid, errorMessage) {\\\\n    const errorElement = this.getErrorElement(field);\\\\n    \\\\n    if (isValid) {\\\\n      field.classList.remove('error');\\\\n      field.classList.add('success');\\\\n      errorElement.textContent = '';\\\\n    } else {\\\\n      field.classList.add('error');\\\\n      field.classList.remove('success');\\\\n      errorElement.textContent = errorMessage;\\\\n    }\\\\n  }\\\\n  \\\\n  clearError(field) {\\\\n    field.classList.remove('error', 'success');\\\\n    const errorElement = this.getErrorElement(field);\\\\n    errorElement.textContent = '';\\\\n  }\\\\n  \\\\n  getErrorElement(field) {\\\\n    let errorElement = field.parentNode.querySelector('.error-message');\\\\n    \\\\n    if (!errorElement) {\\\\n      errorElement = document.createElement('div');\\\\n      errorElement.className = 'error-message';\\\\n      field.parentNode.appendChild(errorElement);\\\\n    }\\\\n    \\\\n    return errorElement;\\\\n  }\\\\n  \\\\n  handleSubmit(e) {\\\\n    e.preventDefault();\\\\n    \\\\n    let allValid = true;\\\\n    this.fields.forEach(field => {\\\\n      if (!this.validateField(field)) {\\\\n        allValid = false;\\\\n      }\\\\n    });\\\\n    \\\\n    if (allValid) {\\\\n      this.submitForm();\\\\n    } else {\\\\n      const firstError = this.form.querySelector('.error');\\\\n      if (firstError) {\\\\n        firstError.focus();\\\\n      }\\\\n    }\\\\n  }\\\\n  \\\\n  async submitForm() {\\\\n    const submitBtn = this.form.querySelector('button[type=\\\\\\\"submit\\\\\\\"]');\\\\n    const originalText = submitBtn.textContent;\\\\n    \\\\n    submitBtn.disabled = true;\\\\n    submitBtn.textContent = 'Submitting...';\\\\n    \\\\n    try {\\\\n      const formData = new FormData(this.form);\\\\n      const response = await fetch(this.form.action, {\\\\n        method: this.form.method,\\\\n        body: formData\\\\n      });\\\\n      \\\\n      if (response.ok) {\\\\n        this.showMessage('Form submitted successfully!', 'success');\\\\n        this.form.reset();\\\\n      } else {\\\\n        throw new Error('Submission failed');\\\\n      }\\\\n    } catch (error) {\\\\n      this.showMessage('Error submitting form. Please try again.', 'error');\\\\n    } finally {\\\\n      submitBtn.disabled = false;\\\\n      submitBtn.textContent = originalText;\\\\n    }\\\\n  }\\\\n  \\\\n  showMessage(text, type) {\\\\n    const message = document.createElement('div');\\\\n    message.className = `form-message ${type}`;\\\\n    message.textContent = text;\\\\n    \\\\n    this.form.insertBefore(message, this.form.firstChild);\\\\n    \\\\n    setTimeout(() => message.remove(), 5000);\\\\n  }\\\\n}\\\\n\\\\n// Initialize form validators\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  document.querySelectorAll('form').forEach(form => {\\\\n    new FormValidator(form);\\\\n  });\\\\n});"
  },
  "label": {
    "title": "Dynamic Label Behavior",
    "description": "JavaScript can enhance labels with floating animations, dynamic required indicators, and improved accessibility features. These enhancements maintain the semantic relationship between labels and form controls.",
    "code": "<!-- Enhanced label functionality -->\\\\nclass LabelEnhancer {\\\\n  constructor() {\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.enhanceFloatingLabels();\\\\n    this.addRequiredIndicators();\\\\n    this.improveAccessibility();\\\\n  }\\\\n  \\\\n  enhanceFloatingLabels() {\\\\n    const floatingGroups = document.querySelectorAll('.floating-label');\\\\n    \\\\n    floatingGroups.forEach(group => {\\\\n      const input = group.querySelector('input, textarea');\\\\n      const label = group.querySelector('label');\\\\n      \\\\n      if (input && label) {\\\\n        this.setupFloatingBehavior(input, label);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  setupFloatingBehavior(input, label) {\\\\n    const checkFloat = () => {\\\\n      if (input.value.trim() !== '' || input === document.activeElement) {\\\\n        label.classList.add('floating');\\\\n      } else {\\\\n        label.classList.remove('floating');\\\\n      }\\\\n    };\\\\n    \\\\n    input.addEventListener('focus', checkFloat);\\\\n    input.addEventListener('blur', checkFloat);\\\\n    input.addEventListener('input', checkFloat);\\\\n    \\\\n    // Initial check\\\\n    checkFloat();\\\\n  }\\\\n  \\\\n  addRequiredIndicators() {\\\\n    const requiredFields = document.querySelectorAll('input[required], textarea[required], select[required]');\\\\n    \\\\n    requiredFields.forEach(field => {\\\\n      const label = document.querySelector(`label[for=\\\\\\\"${field.id}\\\\\\\"]`) || \\\\n                    field.closest('label');\\\\n      \\\\n      if (label && !label.querySelector('.required-indicator')) {\\\\n        const indicator = document.createElement('span');\\\\n        indicator.className = 'required-indicator';\\\\n        indicator.textContent = ' *';\\\\n        indicator.setAttribute('aria-hidden', 'true');\\\\n        label.appendChild(indicator);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  improveAccessibility() {\\\\n    // Ensure all form controls have associated labels\\\\n    const unlabeledInputs = document.querySelectorAll('input:not([aria-label]):not([aria-labelledby])');\\\\n    \\\\n    unlabeledInputs.forEach(input => {\\\\n      if (!input.id) {\\\\n        input.id = `input-${Math.random().toString(36).substr(2, 9)}`;\\\\n      }\\\\n      \\\\n      const existingLabel = document.querySelector(`label[for=\\\\\\\"${input.id}\\\\\\\"]`);\\\\n      if (!existingLabel && !input.closest('label')) {\\\\n        console.warn('Input missing label:', input);\\\\n      }\\\\n    });\\\\n  }\\\\n}\\\\n\\\\n// Label click enhancement for better UX\\\\nfunction enhanceLabelClicks() {\\\\n  document.querySelectorAll('label').forEach(label => {\\\\n    label.addEventListener('click', (e) => {\\\\n      const forAttr = label.getAttribute('for');\\\\n      const associatedControl = forAttr ? \\\\n        document.getElementById(forAttr) : \\\\n        label.querySelector('input, textarea, select');\\\\n      \\\\n      if (associatedControl) {\\\\n        // Add visual feedback\\\\n        associatedControl.classList.add('label-clicked');\\\\n        setTimeout(() => {\\\\n          associatedControl.classList.remove('label-clicked');\\\\n        }, 200);\\\\n      }\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Initialize label enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  new LabelEnhancer();\\\\n  enhanceLabelClicks();\\\\n});"
  },
  "input": {
    "title": "Advanced Input Functionality",
    "description": "JavaScript can significantly enhance input elements with features like real-time validation, input formatting, auto-completion, and improved user experience. These enhancements work with different input types while maintaining accessibility.",
    "code": "<!-- Advanced input enhancements -->\\\\nclass InputEnhancer {\\\\n  constructor(input) {\\\\n    this.input = input;\\\\n    this.type = input.type;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.addBasicEnhancements();\\\\n    this.addTypeSpecificFeatures();\\\\n    this.addValidationFeedback();\\\\n  }\\\\n  \\\\n  addBasicEnhancements() {\\\\n    // Auto-trim text inputs\\\\n    if (this.type === 'text' || this.type === 'email') {\\\\n      this.input.addEventListener('blur', () => {\\\\n        this.input.value = this.input.value.trim();\\\\n      });\\\\n    }\\\\n    \\\\n    // Character counter for inputs with maxlength\\\\n    if (this.input.hasAttribute('maxlength')) {\\\\n      this.addCharacterCounter();\\\\n    }\\\\n    \\\\n    // Auto-focus next input on Enter (for forms)\\\\n    this.input.addEventListener('keydown', (e) => {\\\\n      if (e.key === 'Enter' && this.type !== 'textarea') {\\\\n        this.focusNextInput();\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  addTypeSpecificFeatures() {\\\\n    switch (this.type) {\\\\n      case 'email':\\\\n        this.enhanceEmailInput();\\\\n        break;\\\\n      case 'tel':\\\\n        this.enhanceTelInput();\\\\n        break;\\\\n      case 'number':\\\\n        this.enhanceNumberInput();\\\\n        break;\\\\n      case 'password':\\\\n        this.enhancePasswordInput();\\\\n        break;\\\\n      case 'search':\\\\n        this.enhanceSearchInput();\\\\n        break;\\\\n    }\\\\n  }\\\\n  \\\\n  enhanceEmailInput() {\\\\n    // Email validation on input\\\\n    this.input.addEventListener('input', () => {\\\\n      const email = this.input.value;\\\\n      const emailRegex = new RegExp('^[^\\\\\\\\\\\\\\\\s@]+@[^\\\\\\\\\\\\\\\\s@]+\\\\\\\\\\\\\\\\.[^\\\\\\\\\\\\\\\\s@]+$');\\\\n      \\\\n      if (email && !emailRegex.test(email)) {\\\\n        this.input.classList.add('invalid');\\\\n      } else {\\\\n        this.input.classList.remove('invalid');\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  enhanceTelInput() {\\\\n    // Phone number formatting\\\\n    this.input.addEventListener('input', (e) => {\\\\n      let value = e.target.value.replace(/\\\\\\\\D/g, '');\\\\n      \\\\n      if (value.length >= 6) {\\\\n        value = value.replace(/(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})/, '($1) $2-$3');\\\\n      } else if (value.length >= 3) {\\\\n        value = value.replace(/(\\\\\\\\d{3})(\\\\\\\\d+)/, '($1) $2');\\\\n      }\\\\n      \\\\n      e.target.value = value;\\\\n    });\\\\n  }\\\\n  \\\\n  enhanceNumberInput() {\\\\n    // Number input with step buttons\\\\n    const wrapper = document.createElement('div');\\\\n    wrapper.className = 'number-input-wrapper';\\\\n    \\\\n    const decreaseBtn = document.createElement('button');\\\\n    decreaseBtn.type = 'button';\\\\n    decreaseBtn.textContent = '−';\\\\n    decreaseBtn.className = 'number-btn decrease';\\\\n    \\\\n    const increaseBtn = document.createElement('button');\\\\n    increaseBtn.type = 'button';\\\\n    increaseBtn.textContent = '+';\\\\n    increaseBtn.className = 'number-btn increase';\\\\n    \\\\n    this.input.parentNode.insertBefore(wrapper, this.input);\\\\n    wrapper.appendChild(decreaseBtn);\\\\n    wrapper.appendChild(this.input);\\\\n    wrapper.appendChild(increaseBtn);\\\\n    \\\\n    const step = parseFloat(this.input.step) || 1;\\\\n    const min = parseFloat(this.input.min);\\\\n    const max = parseFloat(this.input.max);\\\\n    \\\\n    decreaseBtn.addEventListener('click', () => {\\\\n      const currentValue = parseFloat(this.input.value) || 0;\\\\n      const newValue = currentValue - step;\\\\n      \\\\n      if (isNaN(min) || newValue >= min) {\\\\n        this.input.value = newValue;\\\\n        this.input.dispatchEvent(new Event('input'));\\\\n      }\\\\n    });\\\\n    \\\\n    increaseBtn.addEventListener('click', () => {\\\\n      const currentValue = parseFloat(this.input.value) || 0;\\\\n      const newValue = currentValue + step;\\\\n      \\\\n      if (isNaN(max) || newValue <= max) {\\\\n        this.input.value = newValue;\\\\n        this.input.dispatchEvent(new Event('input'));\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  enhancePasswordInput() {\\\\n    // Password visibility toggle\\\\n    const toggleBtn = document.createElement('button');\\\\n    toggleBtn.type = 'button';\\\\n    toggleBtn.className = 'password-toggle';\\\\n    toggleBtn.innerHTML = '👁';\\\\n    toggleBtn.setAttribute('aria-label', 'Toggle password visibility');\\\\n    \\\\n    const wrapper = document.createElement('div');\\\\n    wrapper.className = 'password-input-wrapper';\\\\n    \\\\n    this.input.parentNode.insertBefore(wrapper, this.input);\\\\n    wrapper.appendChild(this.input);\\\\n    wrapper.appendChild(toggleBtn);\\\\n    \\\\n    toggleBtn.addEventListener('click', () => {\\\\n      if (this.input.type === 'password') {\\\\n        this.input.type = 'text';\\\\n        toggleBtn.innerHTML = '🙈';\\\\n        toggleBtn.setAttribute('aria-label', 'Hide password');\\\\n      } else {\\\\n        this.input.type = 'password';\\\\n        toggleBtn.innerHTML = '👁';\\\\n        toggleBtn.setAttribute('aria-label', 'Show password');\\\\n      }\\\\n    });\\\\n    \\\\n    // Password strength indicator\\\\n    this.addPasswordStrengthMeter();\\\\n  }\\\\n  \\\\n  enhanceSearchInput() {\\\\n    // Clear button for search inputs\\\\n    const clearBtn = document.createElement('button');\\\\n    clearBtn.type = 'button';\\\\n    clearBtn.className = 'search-clear';\\\\n    clearBtn.innerHTML = '×';\\\\n    clearBtn.style.display = 'none';\\\\n    \\\\n    const wrapper = document.createElement('div');\\\\n    wrapper.className = 'search-input-wrapper';\\\\n    \\\\n    this.input.parentNode.insertBefore(wrapper, this.input);\\\\n    wrapper.appendChild(this.input);\\\\n    wrapper.appendChild(clearBtn);\\\\n    \\\\n    this.input.addEventListener('input', () => {\\\\n      clearBtn.style.display = this.input.value ? 'block' : 'none';\\\\n    });\\\\n    \\\\n    clearBtn.addEventListener('click', () => {\\\\n      this.input.value = '';\\\\n      clearBtn.style.display = 'none';\\\\n      this.input.focus();\\\\n      this.input.dispatchEvent(new Event('input'));\\\\n    });\\\\n  }\\\\n  \\\\n  addCharacterCounter() {\\\\n    const maxLength = parseInt(this.input.getAttribute('maxlength'));\\\\n    const counter = document.createElement('div');\\\\n    counter.className = 'character-counter';\\\\n    \\\\n    this.input.parentNode.appendChild(counter);\\\\n    \\\\n    const updateCounter = () => {\\\\n      const remaining = maxLength - this.input.value.length;\\\\n      counter.textContent = `${remaining} characters remaining`;\\\\n      \\\\n      if (remaining < 10) {\\\\n        counter.classList.add('warning');\\\\n      } else {\\\\n        counter.classList.remove('warning');\\\\n      }\\\\n    };\\\\n    \\\\n    this.input.addEventListener('input', updateCounter);\\\\n    updateCounter();\\\\n  }\\\\n  \\\\n  addPasswordStrengthMeter() {\\\\n    if (this.type !== 'password') return;\\\\n    \\\\n    const meter = document.createElement('div');\\\\n    meter.className = 'password-strength-meter';\\\\n    \\\\n    const bar = document.createElement('div');\\\\n    bar.className = 'strength-bar';\\\\n    \\\\n    const text = document.createElement('div');\\\\n    text.className = 'strength-text';\\\\n    \\\\n    meter.appendChild(bar);\\\\n    meter.appendChild(text);\\\\n    this.input.parentNode.appendChild(meter);\\\\n    \\\\n    this.input.addEventListener('input', () => {\\\\n      const password = this.input.value;\\\\n      const strength = this.calculatePasswordStrength(password);\\\\n      \\\\n      bar.className = `strength-bar strength-${strength.level}`;\\\\n      bar.style.width = `${strength.percentage}%`;\\\\n      text.textContent = strength.text;\\\\n    });\\\\n  }\\\\n  \\\\n  calculatePasswordStrength(password) {\\\\n    let score = 0;\\\\n    \\\\n    if (password.length >= 8) score += 1;\\\\n    if (new RegExp('[a-z]').test(password)) score += 1;\\\\n    if (new RegExp('[A-Z]').test(password)) score += 1;\\\\n    if (new RegExp('[0-9]').test(password)) score += 1;\\\\n    if (new RegExp('[^A-Za-z0-9]').test(password)) score += 1;\\\\n    \\\\n    const levels = [\\\\n      { level: 'weak', text: 'Weak', percentage: 20 },\\\\n      { level: 'fair', text: 'Fair', percentage: 40 },\\\\n      { level: 'good', text: 'Good', percentage: 60 },\\\\n      { level: 'strong', text: 'Strong', percentage: 80 },\\\\n      { level: 'very-strong', text: 'Very Strong', percentage: 100 }\\\\n    ];\\\\n    \\\\n    return levels[Math.max(0, score - 1)] || levels[0];\\\\n  }\\\\n  \\\\n  addValidationFeedback() {\\\\n    this.input.addEventListener('invalid', (e) => {\\\\n      e.preventDefault();\\\\n      this.showValidationMessage(this.input.validationMessage);\\\\n    });\\\\n    \\\\n    this.input.addEventListener('input', () => {\\\\n      this.hideValidationMessage();\\\\n    });\\\\n  }\\\\n  \\\\n  showValidationMessage(message) {\\\\n    let errorElement = this.input.parentNode.querySelector('.validation-message');\\\\n    \\\\n    if (!errorElement) {\\\\n      errorElement = document.createElement('div');\\\\n      errorElement.className = 'validation-message';\\\\n      this.input.parentNode.appendChild(errorElement);\\\\n    }\\\\n    \\\\n    errorElement.textContent = message;\\\\n    this.input.classList.add('invalid');\\\\n  }\\\\n  \\\\n  hideValidationMessage() {\\\\n    const errorElement = this.input.parentNode.querySelector('.validation-message');\\\\n    if (errorElement) {\\\\n      errorElement.textContent = '';\\\\n    }\\\\n    this.input.classList.remove('invalid');\\\\n  }\\\\n  \\\\n  focusNextInput() {\\\\n    const form = this.input.closest('form');\\\\n    if (form) {\\\\n      const inputs = Array.from(form.querySelectorAll('input, textarea, select'));\\\\n      const currentIndex = inputs.indexOf(this.input);\\\\n      const nextInput = inputs[currentIndex + 1];\\\\n      \\\\n      if (nextInput) {\\\\n        nextInput.focus();\\\\n      }\\\\n    }\\\\n  }\\\\n}\\\\n\\\\n// Initialize input enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  document.querySelectorAll('input').forEach(input => {\\\\n    new InputEnhancer(input);\\\\n  });\\\\n});"
  },
  "textarea": {
    "title": "Textarea Auto-resize and Enhancement",
    "description": "JavaScript can enhance textarea elements with auto-resize functionality, character counting, and improved user experience features. These enhancements maintain accessibility while providing better usability.",
    "code": "<!-- Enhanced textarea functionality -->\\\\nclass TextareaEnhancer {\\\\n  constructor(textarea) {\\\\n    this.textarea = textarea;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.setupAutoResize();\\\\n    this.addCharacterCounter();\\\\n    this.addTabSupport();\\\\n    this.addUndoRedo();\\\\n  }\\\\n  \\\\n  setupAutoResize() {\\\\n    // Auto-resize textarea to fit content\\\\n    const resize = () => {\\\\n      this.textarea.style.height = 'auto';\\\\n      this.textarea.style.height = this.textarea.scrollHeight + 'px';\\\\n    };\\\\n    \\\\n    this.textarea.addEventListener('input', resize);\\\\n    this.textarea.addEventListener('paste', () => {\\\\n      setTimeout(resize, 0);\\\\n    });\\\\n    \\\\n    // Initial resize\\\\n    resize();\\\\n  }\\\\n  \\\\n  addCharacterCounter() {\\\\n    const maxLength = this.textarea.getAttribute('maxlength');\\\\n    if (!maxLength) return;\\\\n    \\\\n    const counter = document.createElement('div');\\\\n    counter.className = 'textarea-counter';\\\\n    \\\\n    // Position counter absolutely within wrapper\\\\n    const wrapper = document.createElement('div');\\\\n    wrapper.className = 'textarea-wrapper';\\\\n    wrapper.style.position = 'relative';\\\\n    \\\\n    this.textarea.parentNode.insertBefore(wrapper, this.textarea);\\\\n    wrapper.appendChild(this.textarea);\\\\n    wrapper.appendChild(counter);\\\\n    \\\\n    const updateCounter = () => {\\\\n      const remaining = parseInt(maxLength) - this.textarea.value.length;\\\\n      const percentage = (this.textarea.value.length / parseInt(maxLength)) * 100;\\\\n      \\\\n      counter.textContent = `${this.textarea.value.length}/${maxLength}`;\\\\n      \\\\n      // Add warning classes\\\\n      counter.classList.remove('warning', 'error');\\\\n      if (percentage > 90) {\\\\n        counter.classList.add('error');\\\\n      } else if (percentage > 75) {\\\\n        counter.classList.add('warning');\\\\n      }\\\\n    };\\\\n    \\\\n    this.textarea.addEventListener('input', updateCounter);\\\\n    updateCounter();\\\\n  }\\\\n  \\\\n  addTabSupport() {\\\\n    // Allow tab character in textarea\\\\n    this.textarea.addEventListener('keydown', (e) => {\\\\n      if (e.key === 'Tab') {\\\\n        e.preventDefault();\\\\n        \\\\n        const start = this.textarea.selectionStart;\\\\n        const end = this.textarea.selectionEnd;\\\\n        const value = this.textarea.value;\\\\n        \\\\n        // Insert tab character\\\\n        this.textarea.value = value.substring(0, start) + '\\\\\\\\t' + value.substring(end);\\\\n        \\\\n        // Restore cursor position\\\\n        this.textarea.selectionStart = this.textarea.selectionEnd = start + 1;\\\\n        \\\\n        // Trigger input event for auto-resize\\\\n        this.textarea.dispatchEvent(new Event('input'));\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  addUndoRedo() {\\\\n    let history = [this.textarea.value];\\\\n    let historyIndex = 0;\\\\n    \\\\n    // Save state on significant changes\\\\n    let timeout;\\\\n    this.textarea.addEventListener('input', () => {\\\\n      clearTimeout(timeout);\\\\n      timeout = setTimeout(() => {\\\\n        const currentValue = this.textarea.value;\\\\n        if (currentValue !== history[historyIndex]) {\\\\n          history = history.slice(0, historyIndex + 1);\\\\n          history.push(currentValue);\\\\n          historyIndex = history.length - 1;\\\\n          \\\\n          // Limit history size\\\\n          if (history.length > 50) {\\\\n            history = history.slice(-50);\\\\n            historyIndex = history.length - 1;\\\\n          }\\\\n        }\\\\n      }, 500);\\\\n    });\\\\n    \\\\n    // Handle Ctrl+Z (undo) and Ctrl+Y (redo)\\\\n    this.textarea.addEventListener('keydown', (e) => {\\\\n      if (e.ctrlKey || e.metaKey) {\\\\n        if (e.key === 'z' && !e.shiftKey) {\\\\n          e.preventDefault();\\\\n          if (historyIndex > 0) {\\\\n            historyIndex--;\\\\n            this.textarea.value = history[historyIndex];\\\\n            this.textarea.dispatchEvent(new Event('input'));\\\\n          }\\\\n        } else if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {\\\\n          e.preventDefault();\\\\n          if (historyIndex < history.length - 1) {\\\\n            historyIndex++;\\\\n            this.textarea.value = history[historyIndex];\\\\n            this.textarea.dispatchEvent(new Event('input'));\\\\n          }\\\\n        }\\\\n      }\\\\n    });\\\\n  }\\\\n}\\\\n\\\\n// Add markdown/code support for specific textareas\\\\nclass CodeTextarea {\\\\n  constructor(textarea) {\\\\n    this.textarea = textarea;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.addLineNumbers();\\\\n    this.addSyntaxHighlighting();\\\\n    this.addAutoIndentation();\\\\n  }\\\\n  \\\\n  addLineNumbers() {\\\\n    const wrapper = document.createElement('div');\\\\n    wrapper.className = 'code-textarea-wrapper';\\\\n    \\\\n    const lineNumbers = document.createElement('div');\\\\n    lineNumbers.className = 'line-numbers';\\\\n    \\\\n    this.textarea.parentNode.insertBefore(wrapper, this.textarea);\\\\n    wrapper.appendChild(lineNumbers);\\\\n    wrapper.appendChild(this.textarea);\\\\n    \\\\n    const updateLineNumbers = () => {\\\\n      const lines = this.textarea.value.split('\\\\\\\\n').length;\\\\n      const lineNumbersHtml = Array.from({ length: lines }, (_, i) => \\\\n        `<div class=\\\\\\\"line-number\\\\\\\">${i + 1}</div>`\\\\n      ).join('');\\\\n      \\\\n      lineNumbers.innerHTML = lineNumbersHtml;\\\\n    };\\\\n    \\\\n    this.textarea.addEventListener('input', updateLineNumbers);\\\\n    this.textarea.addEventListener('scroll', () => {\\\\n      lineNumbers.scrollTop = this.textarea.scrollTop;\\\\n    });\\\\n    \\\\n    updateLineNumbers();\\\\n  }\\\\n  \\\\n  addAutoIndentation() {\\\\n    this.textarea.addEventListener('keydown', (e) => {\\\\n      if (e.key === 'Enter') {\\\\n        const cursorPos = this.textarea.selectionStart;\\\\n        const textBeforeCursor = this.textarea.value.substring(0, cursorPos);\\\\n        const currentLine = textBeforeCursor.split('\\\\\\\\n').pop();\\\\n        \\\\n        // Get indentation of current line\\\\n        const indentMatch = currentLine.match(/^(\\\\\\\\s*)/);\\\\n        const currentIndent = indentMatch ? indentMatch[1] : '';\\\\n        \\\\n        // Add extra indent for opening braces\\\\n        let extraIndent = '';\\\\n        if (currentLine.trim().endsWith('{') || currentLine.trim().endsWith(':')) {\\\\n          extraIndent = '  '; // 2 spaces\\\\n        }\\\\n        \\\\n        setTimeout(() => {\\\\n          const start = this.textarea.selectionStart;\\\\n          const value = this.textarea.value;\\\\n          \\\\n          this.textarea.value = value.substring(0, start) + \\\\n                                currentIndent + extraIndent + \\\\n                                value.substring(start);\\\\n          \\\\n          this.textarea.selectionStart = this.textarea.selectionEnd = \\\\n            start + currentIndent.length + extraIndent.length;\\\\n        }, 0);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  addSyntaxHighlighting() {\\\\n    // Basic syntax highlighting overlay (simplified)\\\\n    const overlay = document.createElement('div');\\\\n    overlay.className = 'syntax-overlay';\\\\n    overlay.style.position = 'absolute';\\\\n    overlay.style.top = '0';\\\\n    overlay.style.left = '0';\\\\n    overlay.style.pointerEvents = 'none';\\\\n    overlay.style.color = 'transparent';\\\\n    overlay.style.whiteSpace = 'pre-wrap';\\\\n    overlay.style.wordWrap = 'break-word';\\\\n    \\\\n    const wrapper = this.textarea.parentNode;\\\\n    if (wrapper.classList.contains('code-textarea-wrapper')) {\\\\n      wrapper.style.position = 'relative';\\\\n      wrapper.appendChild(overlay);\\\\n      \\\\n      const updateHighlighting = () => {\\\\n        const text = this.textarea.value;\\\\n        const highlighted = this.highlightSyntax(text);\\\\n        overlay.innerHTML = highlighted;\\\\n      };\\\\n      \\\\n      this.textarea.addEventListener('input', updateHighlighting);\\\\n      this.textarea.addEventListener('scroll', () => {\\\\n        overlay.scrollTop = this.textarea.scrollTop;\\\\n        overlay.scrollLeft = this.textarea.scrollLeft;\\\\n      });\\\\n      \\\\n      updateHighlighting();\\\\n    }\\\\n  }\\\\n  \\\\n  highlightSyntax(text) {\\\\n    // Simple syntax highlighting for common patterns\\\\n    return text.replace(/\\\\\\\\b(function|const|let|var|if|else|for|while|return)\\\\\\\\b/g, '<span class=\\\\\\\"keyword\\\\\\\">$1</span>').replace(/([\\\\\\\"'])((?:(?!\\\\\\\\1)[^\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*)\\\\\\\\1/g, '<span class=\\\\\\\"string\\\\\\\">$&</span>').replace(/\\\\\\\\/\\\\\\\\/.*$/gm, '<span class=\\\\\\\"comment\\\\\\\">$&</span>').replace(/\\\\\\\\b\\\\\\\\d+\\\\\\\\b/g, '<span class=\\\\\\\"number\\\\\\\">$&</span>');\\\\n  }\\\\n}\\\\n\\\\n// Initialize textarea enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  document.querySelectorAll('textarea').forEach(textarea => {\\\\n    new TextareaEnhancer(textarea);\\\\n    \\\\n    // Add code features for textareas with specific classes\\\\n    if (textarea.classList.contains('code-textarea')) {\\\\n      new CodeTextarea(textarea);\\\\n    }\\\\n  });\\\\n});"
  },
  "select": {
    "title": "Enhanced Select Functionality",
    "description": "JavaScript can transform select elements with search functionality, custom styling, multi-select enhancements, and improved accessibility. These features provide better user experience while maintaining semantic structure.",
    "code": "<!-- Enhanced select functionality -->\\\\nclass SelectEnhancer {\\\\n  constructor(select) {\\\\n    this.select = select;\\\\n    this.isMultiple = select.hasAttribute('multiple');\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.addSearchFunctionality();\\\\n    this.enhanceMultiSelect();\\\\n    this.addKeyboardNavigation();\\\\n    this.addCustomStyling();\\\\n  }\\\\n  \\\\n  addSearchFunctionality() {\\\\n    if (this.select.options.length < 5) return; // Only for larger selects\\\\n    \\\\n    const wrapper = document.createElement('div');\\\\n    wrapper.className = 'select-search-wrapper';\\\\n    \\\\n    const searchInput = document.createElement('input');\\\\n    searchInput.type = 'text';\\\\n    searchInput.placeholder = 'Search options...';\\\\n    searchInput.className = 'select-search';\\\\n    \\\\n    this.select.parentNode.insertBefore(wrapper, this.select);\\\\n    wrapper.appendChild(searchInput);\\\\n    wrapper.appendChild(this.select);\\\\n    \\\\n    // Store original options\\\\n    this.originalOptions = Array.from(this.select.options).map(option => ({\\\\n      text: option.textContent,\\\\n      value: option.value,\\\\n      selected: option.selected\\\\n    }));\\\\n    \\\\n    searchInput.addEventListener('input', (e) => {\\\\n      this.filterOptions(e.target.value);\\\\n    });\\\\n    \\\\n    // Hide search when select is not focused\\\\n    this.select.addEventListener('blur', () => {\\\\n      setTimeout(() => {\\\\n        if (document.activeElement !== searchInput) {\\\\n          searchInput.style.display = 'none';\\\\n        }\\\\n      }, 100);\\\\n    });\\\\n    \\\\n    this.select.addEventListener('focus', () => {\\\\n      searchInput.style.display = 'block';\\\\n    });\\\\n  }\\\\n  \\\\n  filterOptions(searchTerm) {\\\\n    const term = searchTerm.toLowerCase();\\\\n    \\\\n    // Clear current options\\\\n    this.select.innerHTML = '';\\\\n    \\\\n    // Add filtered options\\\\n    this.originalOptions.forEach(optionData => {\\\\n      if (optionData.text.toLowerCase().includes(term)) {\\\\n        const option = document.createElement('option');\\\\n        option.value = optionData.value;\\\\n        option.textContent = optionData.text;\\\\n        option.selected = optionData.selected;\\\\n        this.select.appendChild(option);\\\\n      }\\\\n    });\\\\n    \\\\n    // If no results, show message\\\\n    if (this.select.options.length === 0) {\\\\n      const option = document.createElement('option');\\\\n      option.textContent = 'No results found';\\\\n      option.disabled = true;\\\\n      this.select.appendChild(option);\\\\n    }\\\\n  }\\\\n  \\\\n  enhanceMultiSelect() {\\\\n    if (!this.isMultiple) return;\\\\n    \\\\n    // Add select all / deselect all buttons\\\\n    const controls = document.createElement('div');\\\\n    controls.className = 'multi-select-controls';\\\\n    \\\\n    const selectAllBtn = document.createElement('button');\\\\n    selectAllBtn.type = 'button';\\\\n    selectAllBtn.textContent = 'Select All';\\\\n    selectAllBtn.className = 'select-all-btn';\\\\n    \\\\n    const deselectAllBtn = document.createElement('button');\\\\n    deselectAllBtn.type = 'button';\\\\n    deselectAllBtn.textContent = 'Deselect All';\\\\n    deselectAllBtn.className = 'deselect-all-btn';\\\\n    \\\\n    controls.appendChild(selectAllBtn);\\\\n    controls.appendChild(deselectAllBtn);\\\\n    \\\\n    this.select.parentNode.insertBefore(controls, this.select);\\\\n    \\\\n    selectAllBtn.addEventListener('click', () => {\\\\n      Array.from(this.select.options).forEach(option => {\\\\n        if (!option.disabled) {\\\\n          option.selected = true;\\\\n        }\\\\n      });\\\\n      this.select.dispatchEvent(new Event('change'));\\\\n    });\\\\n    \\\\n    deselectAllBtn.addEventListener('click', () => {\\\\n      Array.from(this.select.options).forEach(option => {\\\\n        option.selected = false;\\\\n      });\\\\n      this.select.dispatchEvent(new Event('change'));\\\\n    });\\\\n    \\\\n    // Add selection counter\\\\n    this.addSelectionCounter();\\\\n  }\\\\n  \\\\n  addSelectionCounter() {\\\\n    const counter = document.createElement('div');\\\\n    counter.className = 'selection-counter';\\\\n    \\\\n    this.select.parentNode.appendChild(counter);\\\\n    \\\\n    const updateCounter = () => {\\\\n      const selectedCount = Array.from(this.select.selectedOptions).length;\\\\n      const totalCount = this.select.options.length;\\\\n      \\\\n      counter.textContent = `${selectedCount} of ${totalCount} selected`;\\\\n    };\\\\n    \\\\n    this.select.addEventListener('change', updateCounter);\\\\n    updateCounter();\\\\n  }\\\\n  \\\\n  addKeyboardNavigation() {\\\\n    // Enhanced keyboard navigation\\\\n    this.select.addEventListener('keydown', (e) => {\\\\n      const currentIndex = this.select.selectedIndex;\\\\n      \\\\n      switch (e.key) {\\\\n        case 'Home':\\\\n          e.preventDefault();\\\\n          this.select.selectedIndex = 0;\\\\n          break;\\\\n        case 'End':\\\\n          e.preventDefault();\\\\n          this.select.selectedIndex = this.select.options.length - 1;\\\\n          break;\\\\n        case ' ':\\\\n          if (this.isMultiple) {\\\\n            e.preventDefault();\\\\n            const option = this.select.options[currentIndex];\\\\n            if (option) {\\\\n              option.selected = !option.selected;\\\\n              this.select.dispatchEvent(new Event('change'));\\\\n            }\\\\n          }\\\\n          break;\\\\n      }\\\\n    });\\\\n    \\\\n    // Type-ahead functionality\\\\n    let typeAheadTimeout;\\\\n    let typeAheadString = '';\\\\n    \\\\n    this.select.addEventListener('keypress', (e) => {\\\\n      if (e.key.length === 1) {\\\\n        clearTimeout(typeAheadTimeout);\\\\n        typeAheadString += e.key.toLowerCase();\\\\n        \\\\n        // Find matching option\\\\n        const matchingOption = Array.from(this.select.options).find(option => \\\\n          option.textContent.toLowerCase().startsWith(typeAheadString)\\\\n        );\\\\n        \\\\n        if (matchingOption) {\\\\n          this.select.selectedIndex = matchingOption.index;\\\\n        }\\\\n        \\\\n        typeAheadTimeout = setTimeout(() => {\\\\n          typeAheadString = '';\\\\n        }, 1000);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  addCustomStyling() {\\\\n    // Add custom dropdown arrow and container\\\\n    if (!this.isMultiple && !this.select.classList.contains('custom-styled')) {\\\\n      const wrapper = document.createElement('div');\\\\n      wrapper.className = 'custom-select-wrapper';\\\\n      \\\\n      this.select.parentNode.insertBefore(wrapper, this.select);\\\\n      wrapper.appendChild(this.select);\\\\n      \\\\n      this.select.classList.add('custom-styled');\\\\n    }\\\\n  }\\\\n}\\\\n\\\\n// Custom dropdown replacement for advanced features\\\\nclass CustomDropdown {\\\\n  constructor(select) {\\\\n    this.originalSelect = select;\\\\n    this.isOpen = false;\\\\n    this.selectedOptions = [];\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.createCustomDropdown();\\\\n    this.setupEventListeners();\\\\n    this.syncWithOriginal();\\\\n  }\\\\n  \\\\n  createCustomDropdown() {\\\\n    // Create custom dropdown structure\\\\n    this.container = document.createElement('div');\\\\n    this.container.className = 'custom-dropdown';\\\\n    \\\\n    this.trigger = document.createElement('button');\\\\n    this.trigger.type = 'button';\\\\n    this.trigger.className = 'dropdown-trigger';\\\\n    this.trigger.setAttribute('aria-haspopup', 'listbox');\\\\n    this.trigger.setAttribute('aria-expanded', 'false');\\\\n    \\\\n    this.dropdown = document.createElement('div');\\\\n    this.dropdown.className = 'dropdown-options';\\\\n    this.dropdown.setAttribute('role', 'listbox');\\\\n    this.dropdown.style.display = 'none';\\\\n    \\\\n    this.container.appendChild(this.trigger);\\\\n    this.container.appendChild(this.dropdown);\\\\n    \\\\n    // Replace original select\\\\n    this.originalSelect.style.display = 'none';\\\\n    this.originalSelect.parentNode.insertBefore(this.container, this.originalSelect);\\\\n    \\\\n    this.populateOptions();\\\\n    this.updateTriggerText();\\\\n  }\\\\n  \\\\n  populateOptions() {\\\\n    this.dropdown.innerHTML = '';\\\\n    \\\\n    Array.from(this.originalSelect.options).forEach((option, index) => {\\\\n      const optionElement = document.createElement('div');\\\\n      optionElement.className = 'dropdown-option';\\\\n      optionElement.setAttribute('role', 'option');\\\\n      optionElement.setAttribute('data-value', option.value);\\\\n      optionElement.textContent = option.textContent;\\\\n      \\\\n      if (option.selected) {\\\\n        optionElement.classList.add('selected');\\\\n      }\\\\n      \\\\n      if (option.disabled) {\\\\n        optionElement.classList.add('disabled');\\\\n      }\\\\n      \\\\n      this.dropdown.appendChild(optionElement);\\\\n    });\\\\n  }\\\\n  \\\\n  setupEventListeners() {\\\\n    this.trigger.addEventListener('click', () => {\\\\n      this.toggle();\\\\n    });\\\\n    \\\\n    this.dropdown.addEventListener('click', (e) => {\\\\n      const option = e.target.closest('.dropdown-option');\\\\n      if (option && !option.classList.contains('disabled')) {\\\\n        this.selectOption(option);\\\\n      }\\\\n    });\\\\n    \\\\n    // Close on outside click\\\\n    document.addEventListener('click', (e) => {\\\\n      if (!this.container.contains(e.target)) {\\\\n        this.close();\\\\n      }\\\\n    });\\\\n    \\\\n    // Keyboard navigation\\\\n    this.container.addEventListener('keydown', (e) => {\\\\n      this.handleKeydown(e);\\\\n    });\\\\n  }\\\\n  \\\\n  toggle() {\\\\n    if (this.isOpen) {\\\\n      this.close();\\\\n    } else {\\\\n      this.open();\\\\n    }\\\\n  }\\\\n  \\\\n  open() {\\\\n    this.isOpen = true;\\\\n    this.dropdown.style.display = 'block';\\\\n    this.trigger.setAttribute('aria-expanded', 'true');\\\\n    this.container.classList.add('open');\\\\n  }\\\\n  \\\\n  close() {\\\\n    this.isOpen = false;\\\\n    this.dropdown.style.display = 'none';\\\\n    this.trigger.setAttribute('aria-expanded', 'false');\\\\n    this.container.classList.remove('open');\\\\n  }\\\\n  \\\\n  selectOption(optionElement) {\\\\n    const value = optionElement.getAttribute('data-value');\\\\n    const originalOption = Array.from(this.originalSelect.options)\\\\n      .find(opt => opt.value === value);\\\\n    \\\\n    if (originalOption) {\\\\n      originalOption.selected = true;\\\\n      this.originalSelect.dispatchEvent(new Event('change'));\\\\n      this.syncWithOriginal();\\\\n      this.close();\\\\n    }\\\\n  }\\\\n  \\\\n  syncWithOriginal() {\\\\n    // Update custom dropdown to match original select\\\\n    const selectedOptions = Array.from(this.originalSelect.selectedOptions);\\\\n    \\\\n    this.dropdown.querySelectorAll('.dropdown-option').forEach(option => {\\\\n      const value = option.getAttribute('data-value');\\\\n      const isSelected = selectedOptions.some(opt => opt.value === value);\\\\n      \\\\n      option.classList.toggle('selected', isSelected);\\\\n    });\\\\n    \\\\n    this.updateTriggerText();\\\\n  }\\\\n  \\\\n  updateTriggerText() {\\\\n    const selectedOptions = Array.from(this.originalSelect.selectedOptions);\\\\n    \\\\n    if (selectedOptions.length === 0) {\\\\n      this.trigger.textContent = 'Select an option';\\\\n    } else if (selectedOptions.length === 1) {\\\\n      this.trigger.textContent = selectedOptions[0].textContent;\\\\n    } else {\\\\n      this.trigger.textContent = `${selectedOptions.length} options selected`;\\\\n    }\\\\n  }\\\\n  \\\\n  handleKeydown(e) {\\\\n    const options = Array.from(this.dropdown.querySelectorAll('.dropdown-option:not(.disabled)'));\\\\n    const focusedOption = this.dropdown.querySelector('.dropdown-option.focused');\\\\n    let currentIndex = focusedOption ? options.indexOf(focusedOption) : -1;\\\\n    \\\\n    switch (e.key) {\\\\n      case 'ArrowDown':\\\\n        e.preventDefault();\\\\n        if (!this.isOpen) {\\\\n          this.open();\\\\n        } else {\\\\n          currentIndex = Math.min(currentIndex + 1, options.length - 1);\\\\n          this.focusOption(options[currentIndex]);\\\\n        }\\\\n        break;\\\\n      case 'ArrowUp':\\\\n        e.preventDefault();\\\\n        if (this.isOpen) {\\\\n          currentIndex = Math.max(currentIndex - 1, 0);\\\\n          this.focusOption(options[currentIndex]);\\\\n        }\\\\n        break;\\\\n      case 'Enter':\\\\n      case ' ':\\\\n        e.preventDefault();\\\\n        if (this.isOpen && focusedOption) {\\\\n          this.selectOption(focusedOption);\\\\n        } else {\\\\n          this.open();\\\\n        }\\\\n        break;\\\\n      case 'Escape':\\\\n        this.close();\\\\n        break;\\\\n    }\\\\n  }\\\\n  \\\\n  focusOption(option) {\\\\n    this.dropdown.querySelectorAll('.dropdown-option').forEach(opt => {\\\\n      opt.classList.remove('focused');\\\\n    });\\\\n    \\\\n    if (option) {\\\\n      option.classList.add('focused');\\\\n    }\\\\n  }\\\\n}\\\\n\\\\n// Initialize select enhancements\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  document.querySelectorAll('select').forEach(select => {\\\\n    if (select.classList.contains('custom-dropdown-enabled')) {\\\\n      new CustomDropdown(select);\\\\n    } else {\\\\n      new SelectEnhancer(select);\\\\n    }\\\\n  });\\\\n});"
  },
  "tabs": {
    "title": "Interactive Tab Management",
    "description": "JavaScript enables tab functionality with keyboard navigation, dynamic content loading, and accessibility features. The implementation handles ARIA attributes, focus management, and responsive behavior.",
    "code": "<!-- Tab interface implementation -->\\\\nclass TabManager {\\\\n  constructor(tabContainer) {\\\\n    this.container = tabContainer;\\\\n    this.tabList = tabContainer.querySelector('[role=\\\\\\\"tablist\\\\\\\"]');\\\\n    this.tabs = Array.from(tabContainer.querySelectorAll('[role=\\\\\\\"tab\\\\\\\"]'));\\\\n    this.panels = Array.from(tabContainer.querySelectorAll('[role=\\\\\\\"tabpanel\\\\\\\"]'));\\\\n    this.currentTab = 0;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.setupEventListeners();\\\\n    this.setupKeyboardNavigation();\\\\n    this.setInitialState();\\\\n    this.makeResponsive();\\\\n  }\\\\n  \\\\n  setupEventListeners() {\\\\n    this.tabs.forEach((tab, index) => {\\\\n      tab.addEventListener('click', (e) => {\\\\n        e.preventDefault();\\\\n        this.activateTab(index);\\\\n      });\\\\n    });\\\\n  }\\\\n  \\\\n  setupKeyboardNavigation() {\\\\n    this.tabList.addEventListener('keydown', (e) => {\\\\n      let newIndex = this.currentTab;\\\\n      \\\\n      switch (e.key) {\\\\n        case 'ArrowRight':\\\\n        case 'ArrowDown':\\\\n          e.preventDefault();\\\\n          newIndex = (this.currentTab + 1) % this.tabs.length;\\\\n          break;\\\\n        case 'ArrowLeft':\\\\n        case 'ArrowUp':\\\\n          e.preventDefault();\\\\n          newIndex = (this.currentTab - 1 + this.tabs.length) % this.tabs.length;\\\\n          break;\\\\n        case 'Home':\\\\n          e.preventDefault();\\\\n          newIndex = 0;\\\\n          break;\\\\n        case 'End':\\\\n          e.preventDefault();\\\\n          newIndex = this.tabs.length - 1;\\\\n          break;\\\\n        case 'Enter':\\\\n        case ' ':\\\\n          e.preventDefault();\\\\n          this.activateTab(this.currentTab);\\\\n          return;\\\\n      }\\\\n      \\\\n      if (newIndex !== this.currentTab) {\\\\n        this.focusTab(newIndex);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  setInitialState() {\\\\n    // Find initially active tab or default to first\\\\n    const initiallyActive = this.tabs.findIndex(tab => \\\\n      tab.getAttribute('aria-selected') === 'true'\\\\n    );\\\\n    \\\\n    this.activateTab(initiallyActive >= 0 ? initiallyActive : 0);\\\\n  }\\\\n  \\\\n  activateTab(index) {\\\\n    if (index < 0 || index >= this.tabs.length) return;\\\\n    \\\\n    const previousTab = this.currentTab;\\\\n    this.currentTab = index;\\\\n    \\\\n    // Update tabs\\\\n    this.tabs.forEach((tab, i) => {\\\\n      const isActive = i === index;\\\\n      tab.setAttribute('aria-selected', isActive.toString());\\\\n      tab.setAttribute('tabindex', isActive ? '0' : '-1');\\\\n      \\\\n      if (isActive) {\\\\n        tab.focus();\\\\n      }\\\\n    });\\\\n    \\\\n    // Update panels\\\\n    this.panels.forEach((panel, i) => {\\\\n      const isActive = i === index;\\\\n      panel.hidden = !isActive;\\\\n      \\\\n      if (isActive) {\\\\n        // Trigger panel activation event\\\\n        this.onPanelActivate(panel, previousTab !== index);\\\\n      }\\\\n    });\\\\n    \\\\n    // Dispatch custom event\\\\n    this.container.dispatchEvent(new CustomEvent('tabchange', {\\\\n      detail: { \\\\n        activeIndex: index, \\\\n        activeTab: this.tabs[index], \\\\n        activePanel: this.panels[index] \\\\n      }\\\\n    }));\\\\n  }\\\\n  \\\\n  focusTab(index) {\\\\n    if (index < 0 || index >= this.tabs.length) return;\\\\n    \\\\n    // Update tabindex for all tabs\\\\n    this.tabs.forEach((tab, i) => {\\\\n      tab.setAttribute('tabindex', i === index ? '0' : '-1');\\\\n    });\\\\n    \\\\n    this.tabs[index].focus();\\\\n    this.currentTab = index;\\\\n  }\\\\n  \\\\n  onPanelActivate(panel, isNewActivation) {\\\\n    // Handle lazy loading\\\\n    if (isNewActivation && panel.hasAttribute('data-lazy-load')) {\\\\n      this.loadPanelContent(panel);\\\\n    }\\\\n    \\\\n    // Auto-focus first focusable element in panel\\\\n    if (isNewActivation) {\\\\n      const firstFocusable = panel.querySelector(\\\\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\\\\\\\"-1\\\\\\\"])'\\\\n      );\\\\n      \\\\n      if (firstFocusable) {\\\\n        setTimeout(() => firstFocusable.focus(), 100);\\\\n      }\\\\n    }\\\\n  }\\\\n  \\\\n  async loadPanelContent(panel) {\\\\n    const url = panel.getAttribute('data-lazy-load');\\\\n    if (!url) return;\\\\n    \\\\n    try {\\\\n      panel.innerHTML = '<div class=\\\\\\\"loading\\\\\\\">Loading...</div>';\\\\n      \\\\n      const response = await fetch(url);\\\\n      const content = await response.text();\\\\n      \\\\n      panel.innerHTML = content;\\\\n      panel.removeAttribute('data-lazy-load');\\\\n    } catch (error) {\\\\n      panel.innerHTML = '<div class=\\\\\\\"error\\\\\\\">Failed to load content</div>';\\\\n      console.error('Failed to load tab content:', error);\\\\n    }\\\\n  }\\\\n  \\\\n  makeResponsive() {\\\\n    // Handle responsive behavior\\\\n    const checkResponsive = () => {\\\\n      if (window.innerWidth < 768) {\\\\n        this.container.classList.add('tabs-mobile');\\\\n        this.setupMobileBehavior();\\\\n      } else {\\\\n        this.container.classList.remove('tabs-mobile');\\\\n        this.removeMobileBehavior();\\\\n      }\\\\n    };\\\\n    \\\\n    window.addEventListener('resize', checkResponsive);\\\\n    checkResponsive();\\\\n  }\\\\n  \\\\n  setupMobileBehavior() {\\\\n    // Convert to accordion-style on mobile\\\\n    if (this.container.classList.contains('mobile-accordion')) {\\\\n      this.tabs.forEach((tab, index) => {\\\\n        const panel = this.panels[index];\\\\n        if (panel) {\\\\n          // Insert tab before its panel\\\\n          panel.parentNode.insertBefore(tab, panel);\\\\n          \\\\n          // Make tab behave like accordion header\\\\n          tab.addEventListener('click', () => {\\\\n            const isExpanded = panel.hidden === false;\\\\n            \\\\n            // Close all panels\\\\n            this.panels.forEach(p => p.hidden = true);\\\\n            \\\\n            // Toggle current panel\\\\n            panel.hidden = isExpanded;\\\\n          });\\\\n        }\\\\n      });\\\\n    }\\\\n  }\\\\n  \\\\n  removeMobileBehavior() {\\\\n    // Restore original tab structure\\\\n    this.tabs.forEach(tab => {\\\\n      this.tabList.appendChild(tab);\\\\n    });\\\\n  }\\\\n  \\\\n  // Public API methods\\\\n  addTab(tabContent, panelContent, index = -1) {\\\\n    const tabId = `tab-${Date.now()}`;\\\\n    const panelId = `panel-${Date.now()}`;\\\\n    \\\\n    // Create tab\\\\n    const tab = document.createElement('button');\\\\n    tab.setAttribute('role', 'tab');\\\\n    tab.setAttribute('aria-controls', panelId);\\\\n    tab.setAttribute('aria-selected', 'false');\\\\n    tab.setAttribute('tabindex', '-1');\\\\n    tab.id = tabId;\\\\n    tab.innerHTML = tabContent;\\\\n    \\\\n    // Create panel\\\\n    const panel = document.createElement('div');\\\\n    panel.setAttribute('role', 'tabpanel');\\\\n    panel.setAttribute('aria-labelledby', tabId);\\\\n    panel.id = panelId;\\\\n    panel.hidden = true;\\\\n    panel.innerHTML = panelContent;\\\\n    \\\\n    // Insert at specified position or end\\\\n    if (index >= 0 && index < this.tabs.length) {\\\\n      this.tabList.insertBefore(tab, this.tabs[index]);\\\\n      this.panels[index].parentNode.insertBefore(panel, this.panels[index]);\\\\n    } else {\\\\n      this.tabList.appendChild(tab);\\\\n      this.container.appendChild(panel);\\\\n    }\\\\n    \\\\n    // Update arrays\\\\n    this.tabs = Array.from(this.container.querySelectorAll('[role=\\\\\\\"tab\\\\\\\"]'));\\\\n    this.panels = Array.from(this.container.querySelectorAll('[role=\\\\\\\"tabpanel\\\\\\\"]'));\\\\n    \\\\n    // Reattach event listeners\\\\n    this.setupEventListeners();\\\\n    \\\\n    return { tab, panel };\\\\n  }\\\\n  \\\\n  removeTab(index) {\\\\n    if (index < 0 || index >= this.tabs.length) return;\\\\n    \\\\n    const tab = this.tabs[index];\\\\n    const panel = this.panels[index];\\\\n    \\\\n    tab.remove();\\\\n    panel.remove();\\\\n    \\\\n    // Update arrays\\\\n    this.tabs = Array.from(this.container.querySelectorAll('[role=\\\\\\\"tab\\\\\\\"]'));\\\\n    this.panels = Array.from(this.container.querySelectorAll('[role=\\\\\\\"tabpanel\\\\\\\"]'));\\\\n    \\\\n    // Adjust current tab if necessary\\\\n    if (this.currentTab >= index) {\\\\n      this.currentTab = Math.max(0, this.currentTab - 1);\\\\n    }\\\\n    \\\\n    // Activate a valid tab\\\\n    if (this.tabs.length > 0) {\\\\n      this.activateTab(Math.min(this.currentTab, this.tabs.length - 1));\\\\n    }\\\\n  }\\\\n  \\\\n  getActiveTab() {\\\\n    return {\\\\n      index: this.currentTab,\\\\n      tab: this.tabs[this.currentTab],\\\\n      panel: this.panels[this.currentTab]\\\\n    };\\\\n  }\\\\n}\\\\n\\\\n// Auto-save tab state\\\\nclass TabStateManager {\\\\n  constructor(tabManager, storageKey) {\\\\n    this.tabManager = tabManager;\\\\n    this.storageKey = storageKey || `tab-state-${Date.now()}`;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    // Restore saved state\\\\n    this.restoreState();\\\\n    \\\\n    // Save state on tab change\\\\n    this.tabManager.container.addEventListener('tabchange', () => {\\\\n      this.saveState();\\\\n    });\\\\n  }\\\\n  \\\\n  saveState() {\\\\n    const state = {\\\\n      activeIndex: this.tabManager.currentTab,\\\\n      timestamp: Date.now()\\\\n    };\\\\n    \\\\n    try {\\\\n      localStorage.setItem(this.storageKey, JSON.stringify(state));\\\\n    } catch (error) {\\\\n      console.warn('Failed to save tab state:', error);\\\\n    }\\\\n  }\\\\n  \\\\n  restoreState() {\\\\n    try {\\\\n      const saved = localStorage.getItem(this.storageKey);\\\\n      if (saved) {\\\\n        const state = JSON.parse(saved);\\\\n        \\\\n        // Only restore if not too old (24 hours)\\\\n        if (Date.now() - state.timestamp < 24 * 60 * 60 * 1000) {\\\\n          this.tabManager.activateTab(state.activeIndex);\\\\n        }\\\\n      }\\\\n    } catch (error) {\\\\n      console.warn('Failed to restore tab state:', error);\\\\n    }\\\\n  }\\\\n}\\\\n\\\\n// Initialize tab managers\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  document.querySelectorAll('.tabs-container').forEach(container => {\\\\n    const tabManager = new TabManager(container);\\\\n    \\\\n    // Add state management if enabled\\\\n    if (container.hasAttribute('data-save-state')) {\\\\n      const storageKey = container.getAttribute('data-save-state') || undefined;\\\\n      new TabStateManager(tabManager, storageKey);\\\\n    }\\\\n    \\\\n    // Expose tab manager on container for external access\\\\n    container.tabManager = tabManager;\\\\n  });\\\\n});"
  },
  "tooltip": {
    "title": "Dynamic Tooltip System",
    "description": "JavaScript creates an accessible, performant tooltip system with proper positioning, keyboard support, and customizable behavior. The implementation handles edge cases and provides a smooth user experience.",
    "code": "<!-- Advanced tooltip system -->\\\\nclass TooltipManager {\\\\n  constructor() {\\\\n    this.tooltips = new Map();\\\\n    this.activeTooltip = null;\\\\n    this.showDelay = 500;\\\\n    this.hideDelay = 100;\\\\n    this.showTimeout = null;\\\\n    this.hideTimeout = null;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.createTooltipContainer();\\\\n    this.setupEventListeners();\\\\n    this.setupKeyboardSupport();\\\\n  }\\\\n  \\\\n  createTooltipContainer() {\\\\n    this.container = document.createElement('div');\\\\n    this.container.id = 'tooltip-container';\\\\n    this.container.setAttribute('role', 'tooltip');\\\\n    this.container.className = 'tooltip-popup';\\\\n    this.container.style.cssText = `\\\\n      position: absolute;\\\\n      z-index: 10000;\\\\n      visibility: hidden;\\\\n      opacity: 0;\\\\n      transition: opacity 0.2s, visibility 0.2s;\\\\n      pointer-events: none;\\\\n    `;\\\\n    \\\\n    document.body.appendChild(this.container);\\\\n  }\\\\n  \\\\n  setupEventListeners() {\\\\n    // Use event delegation for better performance\\\\n    document.addEventListener('mouseenter', (e) => {\\\\n      const trigger = e.target.closest('[data-tooltip], [title]');\\\\n      if (trigger) {\\\\n        this.handleMouseEnter(trigger);\\\\n      }\\\\n    }, true);\\\\n    \\\\n    document.addEventListener('mouseleave', (e) => {\\\\n      const trigger = e.target.closest('[data-tooltip], [title]');\\\\n      if (trigger) {\\\\n        this.handleMouseLeave(trigger);\\\\n      }\\\\n    }, true);\\\\n    \\\\n    document.addEventListener('focus', (e) => {\\\\n      const trigger = e.target.closest('[data-tooltip], [title]');\\\\n      if (trigger) {\\\\n        this.handleFocus(trigger);\\\\n      }\\\\n    }, true);\\\\n    \\\\n    document.addEventListener('blur', (e) => {\\\\n      const trigger = e.target.closest('[data-tooltip], [title]');\\\\n      if (trigger) {\\\\n        this.handleBlur(trigger);\\\\n      }\\\\n    }, true);\\\\n    \\\\n    // Hide on scroll\\\\n    document.addEventListener('scroll', () => {\\\\n      this.hide();\\\\n    }, true);\\\\n    \\\\n    // Hide on window resize\\\\n    window.addEventListener('resize', () => {\\\\n      this.hide();\\\\n    });\\\\n  }\\\\n  \\\\n  setupKeyboardSupport() {\\\\n    document.addEventListener('keydown', (e) => {\\\\n      if (e.key === 'Escape' && this.activeTooltip) {\\\\n        this.hide();\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  handleMouseEnter(trigger) {\\\\n    clearTimeout(this.hideTimeout);\\\\n    \\\\n    this.showTimeout = setTimeout(() => {\\\\n      this.show(trigger);\\\\n    }, this.showDelay);\\\\n  }\\\\n  \\\\n  handleMouseLeave(trigger) {\\\\n    clearTimeout(this.showTimeout);\\\\n    \\\\n    this.hideTimeout = setTimeout(() => {\\\\n      this.hide();\\\\n    }, this.hideDelay);\\\\n  }\\\\n  \\\\n  handleFocus(trigger) {\\\\n    clearTimeout(this.hideTimeout);\\\\n    this.show(trigger);\\\\n  }\\\\n  \\\\n  handleBlur(trigger) {\\\\n    this.hide();\\\\n  }\\\\n  \\\\n  show(trigger) {\\\\n    const content = this.getTooltipContent(trigger);\\\\n    if (!content) return;\\\\n    \\\\n    this.activeTooltip = trigger;\\\\n    \\\\n    // Set content\\\\n    this.container.innerHTML = content;\\\\n    \\\\n    // Apply custom styling\\\\n    const tooltipClass = trigger.getAttribute('data-tooltip-class');\\\\n    this.container.className = `tooltip-popup ${tooltipClass || ''}`;\\\\n    \\\\n    // Position tooltip\\\\n    this.positionTooltip(trigger);\\\\n    \\\\n    // Show tooltip\\\\n    this.container.style.visibility = 'visible';\\\\n    this.container.style.opacity = '1';\\\\n    \\\\n    // Set ARIA relationship\\\\n    const tooltipId = `tooltip-${Date.now()}`;\\\\n    this.container.id = tooltipId;\\\\n    trigger.setAttribute('aria-describedby', tooltipId);\\\\n    \\\\n    // Dispatch show event\\\\n    trigger.dispatchEvent(new CustomEvent('tooltip:show', {\\\\n      detail: { tooltip: this.container, content }\\\\n    }));\\\\n  }\\\\n  \\\\n  hide() {\\\\n    if (!this.activeTooltip) return;\\\\n    \\\\n    // Hide tooltip\\\\n    this.container.style.visibility = 'hidden';\\\\n    this.container.style.opacity = '0';\\\\n    \\\\n    // Clean up ARIA relationship\\\\n    this.activeTooltip.removeAttribute('aria-describedby');\\\\n    \\\\n    // Dispatch hide event\\\\n    this.activeTooltip.dispatchEvent(new CustomEvent('tooltip:hide', {\\\\n      detail: { tooltip: this.container }\\\\n    }));\\\\n    \\\\n    this.activeTooltip = null;\\\\n    \\\\n    // Clear timeouts\\\\n    clearTimeout(this.showTimeout);\\\\n    clearTimeout(this.hideTimeout);\\\\n  }\\\\n  \\\\n  getTooltipContent(trigger) {\\\\n    // Priority: data-tooltip > title > aria-label\\\\n    let content = trigger.getAttribute('data-tooltip');\\\\n    \\\\n    if (!content) {\\\\n      content = trigger.getAttribute('title');\\\\n      if (content) {\\\\n        // Move title to data-tooltip to prevent native tooltip\\\\n        trigger.setAttribute('data-tooltip', content);\\\\n        trigger.removeAttribute('title');\\\\n      }\\\\n    }\\\\n    \\\\n    if (!content) {\\\\n      content = trigger.getAttribute('aria-label');\\\\n    }\\\\n    \\\\n    // Support for HTML content\\\\n    if (trigger.hasAttribute('data-tooltip-html')) {\\\\n      const htmlSource = trigger.getAttribute('data-tooltip-html');\\\\n      const sourceElement = document.getElementById(htmlSource);\\\\n      if (sourceElement) {\\\\n        content = sourceElement.innerHTML;\\\\n      }\\\\n    }\\\\n    \\\\n    return content;\\\\n  }\\\\n  \\\\n  positionTooltip(trigger) {\\\\n    const triggerRect = trigger.getBoundingClientRect();\\\\n    const tooltipRect = this.container.getBoundingClientRect();\\\\n    const viewport = {\\\\n      width: window.innerWidth,\\\\n      height: window.innerHeight\\\\n    };\\\\n    \\\\n    const position = trigger.getAttribute('data-tooltip-position') || 'top';\\\\n    const offset = parseInt(trigger.getAttribute('data-tooltip-offset')) || 8;\\\\n    \\\\n    let top, left;\\\\n    \\\\n    // Calculate position based on preference\\\\n    switch (position) {\\\\n      case 'top':\\\\n        top = triggerRect.top - tooltipRect.height - offset;\\\\n        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;\\\\n        break;\\\\n      case 'bottom':\\\\n        top = triggerRect.bottom + offset;\\\\n        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;\\\\n        break;\\\\n      case 'left':\\\\n        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;\\\\n        left = triggerRect.left - tooltipRect.width - offset;\\\\n        break;\\\\n      case 'right':\\\\n        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;\\\\n        left = triggerRect.right + offset;\\\\n        break;\\\\n    }\\\\n    \\\\n    // Adjust for viewport boundaries\\\\n    const adjustedPosition = this.adjustForViewport({\\\\n      top: top + window.scrollY,\\\\n      left: left + window.scrollX\\\\n    }, tooltipRect, viewport, triggerRect, position);\\\\n    \\\\n    this.container.style.top = `${adjustedPosition.top}px`;\\\\n    this.container.style.left = `${adjustedPosition.left}px`;\\\\n    \\\\n    // Add position class for styling\\\\n    this.container.setAttribute('data-position', adjustedPosition.position);\\\\n  }\\\\n  \\\\n  adjustForViewport(pos, tooltipRect, viewport, triggerRect, preferredPosition) {\\\\n    let { top, left } = pos;\\\\n    let finalPosition = preferredPosition;\\\\n    \\\\n    // Horizontal adjustments\\\\n    if (left < 0) {\\\\n      left = 8; // Margin from edge\\\\n    } else if (left + tooltipRect.width > viewport.width) {\\\\n      left = viewport.width - tooltipRect.width - 8;\\\\n    }\\\\n    \\\\n    // Vertical adjustments\\\\n    if (top < window.scrollY) {\\\\n      // Not enough space above, try below\\\\n      top = triggerRect.bottom + window.scrollY + 8;\\\\n      finalPosition = 'bottom';\\\\n    } else if (top + tooltipRect.height > window.scrollY + viewport.height) {\\\\n      // Not enough space below, try above\\\\n      top = triggerRect.top + window.scrollY - tooltipRect.height - 8;\\\\n      finalPosition = 'top';\\\\n    }\\\\n    \\\\n    return { top, left, position: finalPosition };\\\\n  }\\\\n  \\\\n  // Public API\\\\n  setDefaults(options) {\\\\n    if (options.showDelay !== undefined) this.showDelay = options.showDelay;\\\\n    if (options.hideDelay !== undefined) this.hideDelay = options.hideDelay;\\\\n  }\\\\n  \\\\n  showTooltip(trigger, content) {\\\\n    if (typeof trigger === 'string') {\\\\n      trigger = document.querySelector(trigger);\\\\n    }\\\\n    \\\\n    if (trigger && content) {\\\\n      trigger.setAttribute('data-tooltip', content);\\\\n      this.show(trigger);\\\\n    }\\\\n  }\\\\n  \\\\n  hideTooltip() {\\\\n    this.hide();\\\\n  }\\\\n  \\\\n  destroy() {\\\\n    this.hide();\\\\n    this.container.remove();\\\\n    // Event listeners are automatically cleaned up with event delegation\\\\n  }\\\\n}\\\\n\\\\n// Rich tooltip component for complex content\\\\nclass RichTooltip {\\\\n  constructor(trigger, options = {}) {\\\\n    this.trigger = trigger;\\\\n    this.options = {\\\\n      content: '',\\\\n      html: false,\\\\n      placement: 'top',\\\\n      delay: [500, 100], // [show, hide]\\\\n      interactive: false,\\\\n      ...options\\\\n    };\\\\n    \\\\n    this.tooltip = null;\\\\n    this.isVisible = false;\\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.createTooltip();\\\\n    this.attachEventListeners();\\\\n  }\\\\n  \\\\n  createTooltip() {\\\\n    this.tooltip = document.createElement('div');\\\\n    this.tooltip.className = 'rich-tooltip';\\\\n    this.tooltip.setAttribute('role', 'tooltip');\\\\n    \\\\n    if (this.options.html) {\\\\n      this.tooltip.innerHTML = this.options.content;\\\\n    } else {\\\\n      this.tooltip.textContent = this.options.content;\\\\n    }\\\\n    \\\\n    document.body.appendChild(this.tooltip);\\\\n  }\\\\n  \\\\n  attachEventListeners() {\\\\n    this.trigger.addEventListener('mouseenter', () => this.show());\\\\n    this.trigger.addEventListener('mouseleave', () => this.hide());\\\\n    this.trigger.addEventListener('focus', () => this.show());\\\\n    this.trigger.addEventListener('blur', () => this.hide());\\\\n    \\\\n    if (this.options.interactive) {\\\\n      this.tooltip.addEventListener('mouseenter', () => this.cancelHide());\\\\n      this.tooltip.addEventListener('mouseleave', () => this.hide());\\\\n    }\\\\n  }\\\\n  \\\\n  show() {\\\\n    clearTimeout(this.hideTimeout);\\\\n    \\\\n    this.showTimeout = setTimeout(() => {\\\\n      this.tooltip.style.display = 'block';\\\\n      this.positionTooltip();\\\\n      this.tooltip.classList.add('visible');\\\\n      this.isVisible = true;\\\\n      \\\\n      // Set ARIA relationship\\\\n      const id = `rich-tooltip-${Date.now()}`;\\\\n      this.tooltip.id = id;\\\\n      this.trigger.setAttribute('aria-describedby', id);\\\\n    }, this.options.delay[0]);\\\\n  }\\\\n  \\\\n  hide() {\\\\n    clearTimeout(this.showTimeout);\\\\n    \\\\n    this.hideTimeout = setTimeout(() => {\\\\n      this.tooltip.classList.remove('visible');\\\\n      this.isVisible = false;\\\\n      \\\\n      setTimeout(() => {\\\\n        if (!this.isVisible) {\\\\n          this.tooltip.style.display = 'none';\\\\n        }\\\\n      }, 200); // Match CSS transition\\\\n      \\\\n      this.trigger.removeAttribute('aria-describedby');\\\\n    }, this.options.delay[1]);\\\\n  }\\\\n  \\\\n  cancelHide() {\\\\n    clearTimeout(this.hideTimeout);\\\\n  }\\\\n  \\\\n  positionTooltip() {\\\\n    // Similar positioning logic as TooltipManager\\\\n    const triggerRect = this.trigger.getBoundingClientRect();\\\\n    const tooltipRect = this.tooltip.getBoundingClientRect();\\\\n    \\\\n    // Position based on placement option\\\\n    let top, left;\\\\n    \\\\n    switch (this.options.placement) {\\\\n      case 'top':\\\\n        top = triggerRect.top - tooltipRect.height - 8;\\\\n        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;\\\\n        break;\\\\n      case 'bottom':\\\\n        top = triggerRect.bottom + 8;\\\\n        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;\\\\n        break;\\\\n      case 'left':\\\\n        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;\\\\n        left = triggerRect.left - tooltipRect.width - 8;\\\\n        break;\\\\n      case 'right':\\\\n        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;\\\\n        left = triggerRect.right + 8;\\\\n        break;\\\\n    }\\\\n    \\\\n    this.tooltip.style.top = `${top + window.scrollY}px`;\\\\n    this.tooltip.style.left = `${left + window.scrollX}px`;\\\\n  }\\\\n  \\\\n  updateContent(content) {\\\\n    if (this.options.html) {\\\\n      this.tooltip.innerHTML = content;\\\\n    } else {\\\\n      this.tooltip.textContent = content;\\\\n    }\\\\n    \\\\n    if (this.isVisible) {\\\\n      this.positionTooltip();\\\\n    }\\\\n  }\\\\n  \\\\n  destroy() {\\\\n    clearTimeout(this.showTimeout);\\\\n    clearTimeout(this.hideTimeout);\\\\n    this.tooltip.remove();\\\\n    this.trigger.removeAttribute('aria-describedby');\\\\n  }\\\\n}\\\\n\\\\n// Initialize tooltip system\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  // Initialize global tooltip manager\\\\n  window.tooltipManager = new TooltipManager();\\\\n  \\\\n  // Initialize rich tooltips\\\\n  document.querySelectorAll('[data-rich-tooltip]').forEach(trigger => {\\\\n    const content = trigger.getAttribute('data-rich-tooltip');\\\\n    const options = {\\\\n      content,\\\\n      html: trigger.hasAttribute('data-tooltip-html'),\\\\n      placement: trigger.getAttribute('data-tooltip-position') || 'top',\\\\n      interactive: trigger.hasAttribute('data-tooltip-interactive')\\\\n    };\\\\n    \\\\n    new RichTooltip(trigger, options);\\\\n  });\\\\n});"
  },
  "dropdown": {
    "title": "Advanced Dropdown Functionality",
    "description": "JavaScript creates fully accessible dropdown menus with keyboard navigation, proper focus management, and dynamic positioning. The implementation handles complex interactions while maintaining ARIA compliance.",
    "code": "<!-- Comprehensive dropdown menu system -->\\\\nclass DropdownMenu {\\\\n  constructor(trigger, options = {}) {\\\\n    this.trigger = trigger;\\\\n    this.menu = null;\\\\n    this.isOpen = false;\\\\n    this.focusedIndex = -1;\\\\n    this.menuItems = [];\\\\n    \\\\n    this.options = {\\\\n      closeOnClickOutside: true,\\\\n      closeOnEscape: true,\\\\n      autoPosition: true,\\\\n      offset: 4,\\\\n      ...options\\\\n    };\\\\n    \\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.findOrCreateMenu();\\\\n    this.setupARIA();\\\\n    this.attachEventListeners();\\\\n    this.collectMenuItems();\\\\n  }\\\\n  \\\\n  findOrCreateMenu() {\\\\n    // Find existing menu by aria-controls or adjacent sibling\\\\n    const menuId = this.trigger.getAttribute('aria-controls');\\\\n    if (menuId) {\\\\n      this.menu = document.getElementById(menuId);\\\\n    }\\\\n    \\\\n    if (!this.menu) {\\\\n      this.menu = this.trigger.nextElementSibling;\\\\n      if (this.menu && this.menu.getAttribute('role') !== 'menu') {\\\\n        this.menu = null;\\\\n      }\\\\n    }\\\\n    \\\\n    if (!this.menu) {\\\\n      console.warn('Dropdown menu not found for trigger:', this.trigger);\\\\n      return;\\\\n    }\\\\n  }\\\\n  \\\\n  setupARIA() {\\\\n    if (!this.menu) return;\\\\n    \\\\n    // Ensure proper ARIA attributes\\\\n    this.trigger.setAttribute('aria-haspopup', 'true');\\\\n    this.trigger.setAttribute('aria-expanded', 'false');\\\\n    \\\\n    if (!this.menu.id) {\\\\n      this.menu.id = `dropdown-menu-${Date.now()}`;\\\\n    }\\\\n    \\\\n    this.trigger.setAttribute('aria-controls', this.menu.id);\\\\n    this.menu.setAttribute('role', 'menu');\\\\n    this.menu.setAttribute('aria-labelledby', this.trigger.id || '');\\\\n  }\\\\n  \\\\n  attachEventListeners() {\\\\n    if (!this.menu) return;\\\\n    \\\\n    // Trigger events\\\\n    this.trigger.addEventListener('click', (e) => {\\\\n      e.preventDefault();\\\\n      this.toggle();\\\\n    });\\\\n    \\\\n    this.trigger.addEventListener('keydown', (e) => {\\\\n      this.handleTriggerKeydown(e);\\\\n    });\\\\n    \\\\n    // Menu events\\\\n    this.menu.addEventListener('click', (e) => {\\\\n      this.handleMenuClick(e);\\\\n    });\\\\n    \\\\n    this.menu.addEventListener('keydown', (e) => {\\\\n      this.handleMenuKeydown(e);\\\\n    });\\\\n    \\\\n    // Global events\\\\n    if (this.options.closeOnClickOutside) {\\\\n      document.addEventListener('click', (e) => {\\\\n        this.handleOutsideClick(e);\\\\n      });\\\\n    }\\\\n    \\\\n    if (this.options.closeOnEscape) {\\\\n      document.addEventListener('keydown', (e) => {\\\\n        if (e.key === 'Escape' && this.isOpen) {\\\\n          this.close();\\\\n        }\\\\n      });\\\\n    }\\\\n    \\\\n    // Close on scroll/resize\\\\n    window.addEventListener('scroll', () => {\\\\n      if (this.isOpen) this.close();\\\\n    }, true);\\\\n    \\\\n    window.addEventListener('resize', () => {\\\\n      if (this.isOpen) this.position();\\\\n    });\\\\n  }\\\\n  \\\\n  collectMenuItems() {\\\\n    if (!this.menu) return;\\\\n    \\\\n    this.menuItems = Array.from(\\\\n      this.menu.querySelectorAll('[role=\\\\\\\"menuitem\\\\\\\"], [role=\\\\\\\"menuitemcheckbox\\\\\\\"], [role=\\\\\\\"menuitemradio\\\\\\\"]')\\\\n    ).filter(item => !item.hasAttribute('disabled') && !item.classList.contains('disabled'));\\\\n    \\\\n    // Ensure menu items are focusable\\\\n    this.menuItems.forEach((item, index) => {\\\\n      if (!item.hasAttribute('tabindex')) {\\\\n        item.setAttribute('tabindex', '-1');\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  handleTriggerKeydown(e) {\\\\n    switch (e.key) {\\\\n      case 'ArrowDown':\\\\n      case 'ArrowUp':\\\\n      case 'Enter':\\\\n      case ' ':\\\\n        e.preventDefault();\\\\n        this.open();\\\\n        if (this.menuItems.length > 0) {\\\\n          this.focusMenuItem(0);\\\\n        }\\\\n        break;\\\\n    }\\\\n  }\\\\n  \\\\n  handleMenuClick(e) {\\\\n    const menuItem = e.target.closest('[role^=\\\\\\\"menuitem\\\\\\\"]');\\\\n    if (!menuItem) return;\\\\n    \\\\n    e.preventDefault();\\\\n    \\\\n    // Handle different menu item types\\\\n    const role = menuItem.getAttribute('role');\\\\n    \\\\n    if (role === 'menuitemcheckbox') {\\\\n      this.toggleCheckbox(menuItem);\\\\n    } else if (role === 'menuitemradio') {\\\\n      this.selectRadio(menuItem);\\\\n    } else {\\\\n      // Regular menu item - trigger action and close\\\\n      this.triggerAction(menuItem);\\\\n      this.close();\\\\n    }\\\\n  }\\\\n  \\\\n  handleMenuKeydown(e) {\\\\n    switch (e.key) {\\\\n      case 'ArrowDown':\\\\n        e.preventDefault();\\\\n        this.focusNext();\\\\n        break;\\\\n      case 'ArrowUp':\\\\n        e.preventDefault();\\\\n        this.focusPrevious();\\\\n        break;\\\\n      case 'Home':\\\\n        e.preventDefault();\\\\n        this.focusMenuItem(0);\\\\n        break;\\\\n      case 'End':\\\\n        e.preventDefault();\\\\n        this.focusMenuItem(this.menuItems.length - 1);\\\\n        break;\\\\n      case 'Enter':\\\\n      case ' ':\\\\n        e.preventDefault();\\\\n        this.activateCurrentItem();\\\\n        break;\\\\n      case 'Escape':\\\\n        e.preventDefault();\\\\n        this.close();\\\\n        break;\\\\n      default:\\\\n        // Type-ahead functionality\\\\n        this.handleTypeAhead(e.key);\\\\n        break;\\\\n    }\\\\n  }\\\\n  \\\\n  handleOutsideClick(e) {\\\\n    if (!this.isOpen) return;\\\\n    \\\\n    if (!this.trigger.contains(e.target) && !this.menu.contains(e.target)) {\\\\n      this.close();\\\\n    }\\\\n  }\\\\n  \\\\n  toggle() {\\\\n    if (this.isOpen) {\\\\n      this.close();\\\\n    } else {\\\\n      this.open();\\\\n    }\\\\n  }\\\\n  \\\\n  open() {\\\\n    if (this.isOpen || !this.menu) return;\\\\n    \\\\n    this.isOpen = true;\\\\n    this.focusedIndex = -1;\\\\n    \\\\n    // Update ARIA state\\\\n    this.trigger.setAttribute('aria-expanded', 'true');\\\\n    \\\\n    // Show menu\\\\n    this.menu.style.display = 'block';\\\\n    this.menu.hidden = false;\\\\n    \\\\n    // Position menu\\\\n    if (this.options.autoPosition) {\\\\n      this.position();\\\\n    }\\\\n    \\\\n    // Add visual state\\\\n    this.trigger.classList.add('active');\\\\n    this.menu.classList.add('open');\\\\n    \\\\n    // Dispatch event\\\\n    this.trigger.dispatchEvent(new CustomEvent('dropdown:open', {\\\\n      detail: { dropdown: this }\\\\n    }));\\\\n  }\\\\n  \\\\n  close() {\\\\n    if (!this.isOpen || !this.menu) return;\\\\n    \\\\n    this.isOpen = false;\\\\n    this.focusedIndex = -1;\\\\n    \\\\n    // Update ARIA state\\\\n    this.trigger.setAttribute('aria-expanded', 'false');\\\\n    \\\\n    // Hide menu\\\\n    this.menu.style.display = 'none';\\\\n    this.menu.hidden = true;\\\\n    \\\\n    // Remove visual state\\\\n    this.trigger.classList.remove('active');\\\\n    this.menu.classList.remove('open');\\\\n    \\\\n    // Clear focused state from menu items\\\\n    this.menuItems.forEach(item => {\\\\n      item.classList.remove('focused');\\\\n    });\\\\n    \\\\n    // Return focus to trigger\\\\n    this.trigger.focus();\\\\n    \\\\n    // Dispatch event\\\\n    this.trigger.dispatchEvent(new CustomEvent('dropdown:close', {\\\\n      detail: { dropdown: this }\\\\n    }));\\\\n  }\\\\n  \\\\n  position() {\\\\n    if (!this.menu) return;\\\\n    \\\\n    const triggerRect = this.trigger.getBoundingClientRect();\\\\n    const menuRect = this.menu.getBoundingClientRect();\\\\n    const viewport = {\\\\n      width: window.innerWidth,\\\\n      height: window.innerHeight,\\\\n      scrollY: window.scrollY,\\\\n      scrollX: window.scrollX\\\\n    };\\\\n    \\\\n    let top = triggerRect.bottom + this.options.offset;\\\\n    let left = triggerRect.left;\\\\n    \\\\n    // Adjust for right edge\\\\n    if (left + menuRect.width > viewport.width) {\\\\n      left = triggerRect.right - menuRect.width;\\\\n    }\\\\n    \\\\n    // Adjust for bottom edge\\\\n    if (top + menuRect.height > viewport.height + viewport.scrollY) {\\\\n      top = triggerRect.top - menuRect.height - this.options.offset;\\\\n    }\\\\n    \\\\n    // Ensure menu stays within viewport\\\\n    left = Math.max(8, Math.min(left, viewport.width - menuRect.width - 8));\\\\n    top = Math.max(viewport.scrollY + 8, top);\\\\n    \\\\n    this.menu.style.position = 'absolute';\\\\n    this.menu.style.top = `${top}px`;\\\\n    this.menu.style.left = `${left}px`;\\\\n    this.menu.style.zIndex = '1000';\\\\n  }\\\\n  \\\\n  focusMenuItem(index) {\\\\n    if (index < 0 || index >= this.menuItems.length) return;\\\\n    \\\\n    // Remove focus from current item\\\\n    if (this.focusedIndex >= 0) {\\\\n      this.menuItems[this.focusedIndex].classList.remove('focused');\\\\n    }\\\\n    \\\\n    // Focus new item\\\\n    this.focusedIndex = index;\\\\n    const item = this.menuItems[index];\\\\n    item.classList.add('focused');\\\\n    item.focus();\\\\n  }\\\\n  \\\\n  focusNext() {\\\\n    const nextIndex = (this.focusedIndex + 1) % this.menuItems.length;\\\\n    this.focusMenuItem(nextIndex);\\\\n  }\\\\n  \\\\n  focusPrevious() {\\\\n    const prevIndex = (this.focusedIndex - 1 + this.menuItems.length) % this.menuItems.length;\\\\n    this.focusMenuItem(prevIndex);\\\\n  }\\\\n  \\\\n  activateCurrentItem() {\\\\n    if (this.focusedIndex >= 0) {\\\\n      const item = this.menuItems[this.focusedIndex];\\\\n      const role = item.getAttribute('role');\\\\n      \\\\n      if (role === 'menuitemcheckbox') {\\\\n        this.toggleCheckbox(item);\\\\n      } else if (role === 'menuitemradio') {\\\\n        this.selectRadio(item);\\\\n      } else {\\\\n        this.triggerAction(item);\\\\n        this.close();\\\\n      }\\\\n    }\\\\n  }\\\\n  \\\\n  toggleCheckbox(item) {\\\\n    const isChecked = item.getAttribute('aria-checked') === 'true';\\\\n    item.setAttribute('aria-checked', (!isChecked).toString());\\\\n    item.classList.toggle('checked', !isChecked);\\\\n    \\\\n    // Trigger change event\\\\n    item.dispatchEvent(new CustomEvent('menuitem:change', {\\\\n      detail: { checked: !isChecked, item }\\\\n    }));\\\\n  }\\\\n  \\\\n  selectRadio(item) {\\\\n    const group = item.getAttribute('data-group') || 'default';\\\\n    \\\\n    // Uncheck other radio items in the same group\\\\n    this.menuItems.forEach(menuItem => {\\\\n      if (menuItem.getAttribute('role') === 'menuitemradio' && \\\\n          menuItem.getAttribute('data-group') === group) {\\\\n        menuItem.setAttribute('aria-checked', 'false');\\\\n        menuItem.classList.remove('checked');\\\\n      }\\\\n    });\\\\n    \\\\n    // Check selected item\\\\n    item.setAttribute('aria-checked', 'true');\\\\n    item.classList.add('checked');\\\\n    \\\\n    // Trigger change event\\\\n    item.dispatchEvent(new CustomEvent('menuitem:change', {\\\\n      detail: { selected: true, item, group }\\\\n    }));\\\\n  }\\\\n  \\\\n  triggerAction(item) {\\\\n    // Trigger click event for compatibility\\\\n    item.click();\\\\n    \\\\n    // Dispatch custom event\\\\n    item.dispatchEvent(new CustomEvent('menuitem:action', {\\\\n      detail: { item }\\\\n    }));\\\\n  }\\\\n  \\\\n  handleTypeAhead(key) {\\\\n    if (key.length !== 1 || /\\\\\\\\s/.test(key)) return;\\\\n    \\\\n    clearTimeout(this.typeAheadTimeout);\\\\n    this.typeAheadString = (this.typeAheadString || '') + key.toLowerCase();\\\\n    \\\\n    // Find matching item\\\\n    const matchingIndex = this.menuItems.findIndex((item, index) => {\\\\n      return index > this.focusedIndex && \\\\n             item.textContent.toLowerCase().startsWith(this.typeAheadString);\\\\n    });\\\\n    \\\\n    // If no match after current position, search from beginning\\\\n    const finalIndex = matchingIndex >= 0 ? matchingIndex : \\\\n      this.menuItems.findIndex(item => \\\\n        item.textContent.toLowerCase().startsWith(this.typeAheadString)\\\\n      );\\\\n    \\\\n    if (finalIndex >= 0) {\\\\n      this.focusMenuItem(finalIndex);\\\\n    }\\\\n    \\\\n    // Clear type-ahead string after delay\\\\n    this.typeAheadTimeout = setTimeout(() => {\\\\n      this.typeAheadString = '';\\\\n    }, 1000);\\\\n  }\\\\n  \\\\n  // Public API methods\\\\n  addMenuItem(content, action, position = -1) {\\\\n    if (!this.menu) return;\\\\n    \\\\n    const item = document.createElement('div');\\\\n    item.setAttribute('role', 'menuitem');\\\\n    item.setAttribute('tabindex', '-1');\\\\n    item.innerHTML = content;\\\\n    \\\\n    if (typeof action === 'function') {\\\\n      item.addEventListener('click', action);\\\\n    }\\\\n    \\\\n    if (position >= 0 && position < this.menu.children.length) {\\\\n      this.menu.insertBefore(item, this.menu.children[position]);\\\\n    } else {\\\\n      this.menu.appendChild(item);\\\\n    }\\\\n    \\\\n    this.collectMenuItems();\\\\n    return item;\\\\n  }\\\\n  \\\\n  removeMenuItem(item) {\\\\n    if (typeof item === 'number') {\\\\n      item = this.menuItems[item];\\\\n    }\\\\n    \\\\n    if (item && item.parentNode === this.menu) {\\\\n      item.remove();\\\\n      this.collectMenuItems();\\\\n    }\\\\n  }\\\\n  \\\\n  destroy() {\\\\n    this.close();\\\\n    // Event listeners are cleaned up automatically\\\\n  }\\\\n}\\\\n\\\\n// Dropdown factory and initialization\\\\nclass DropdownFactory {\\\\n  static dropdowns = new Map();\\\\n  \\\\n  static create(trigger, options = {}) {\\\\n    if (this.dropdowns.has(trigger)) {\\\\n      return this.dropdowns.get(trigger);\\\\n    }\\\\n    \\\\n    const dropdown = new DropdownMenu(trigger, options);\\\\n    this.dropdowns.set(trigger, dropdown);\\\\n    return dropdown;\\\\n  }\\\\n  \\\\n  static destroy(trigger) {\\\\n    const dropdown = this.dropdowns.get(trigger);\\\\n    if (dropdown) {\\\\n      dropdown.destroy();\\\\n      this.dropdowns.delete(trigger);\\\\n    }\\\\n  }\\\\n  \\\\n  static closeAll() {\\\\n    this.dropdowns.forEach(dropdown => dropdown.close());\\\\n  }\\\\n}\\\\n\\\\n// Initialize dropdowns on page load\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  // Auto-initialize dropdowns with data attributes\\\\n  document.querySelectorAll('[data-dropdown]').forEach(trigger => {\\\\n    const options = {};\\\\n    \\\\n    // Parse data attributes for options\\\\n    if (trigger.hasAttribute('data-dropdown-auto-position')) {\\\\n      options.autoPosition = trigger.getAttribute('data-dropdown-auto-position') !== 'false';\\\\n    }\\\\n    \\\\n    if (trigger.hasAttribute('data-dropdown-offset')) {\\\\n      options.offset = parseInt(trigger.getAttribute('data-dropdown-offset'));\\\\n    }\\\\n    \\\\n    DropdownFactory.create(trigger, options);\\\\n  });\\\\n  \\\\n  // Close all dropdowns when clicking outside\\\\n  document.addEventListener('focusin', (e) => {\\\\n    // Close dropdowns when focus moves to unrelated elements\\\\n    const openDropdowns = Array.from(DropdownFactory.dropdowns.values())\\\\n      .filter(dropdown => dropdown.isOpen);\\\\n    \\\\n    openDropdowns.forEach(dropdown => {\\\\n      if (!dropdown.trigger.contains(e.target) && \\\\n          !dropdown.menu.contains(e.target)) {\\\\n        dropdown.close();\\\\n      }\\\\n    });\\\\n  });\\\\n});\\\\n\\\\n// Export for external use\\\\nwindow.DropdownMenu = DropdownMenu;\\\\nwindow.DropdownFactory = DropdownFactory;"
  },
  "checkbox": {
    "title": "Managing Checkbox State",
    "description": "For custom checkboxes, JavaScript is optional for basic functionality since the browser handles the checked state. However, you might want to add JavaScript to handle form validation, create dependent checkboxes, or trigger other actions when the checkbox changes.",
    "code": "const checkbox = document.getElementById('custom-checkbox-1');\\\\n\\\\ncheckbox.addEventListener('change', (e) => {\\\\n  console.log('Checkbox is now:', e.target.checked ? 'checked' : 'unchecked');\\\\n  \\\\n  // Example: Enable/disable other form elements\\\\n  const submitButton = document.getElementById('submit-btn');\\\\n  if (e.target.checked) {\\\\n    submitButton.disabled = false;\\\\n  } else {\\\\n    submitButton.disabled = true;\\\\n  }\\\\n});"
  },
  "radio_group": {
    "title": "Radio Button Group Logic",
    "description": "Radio buttons work as a group automatically when they share the same `name` attribute. JavaScript can be used to handle the selection change and perform actions based on the selected value.",
    "code": "const radioButtons = document.querySelectorAll('input[name=\\\\\\\"options\\\\\\\"]');\\\\n\\\\nradioButtons.forEach(radio => {\\\\n  radio.addEventListener('change', (e) => {\\\\n    if (e.target.checked) {\\\\n      console.log('Selected option:', e.target.value);\\\\n      \\\\n      // Example: Show different content based on selection\\\\n      const selectedValue = e.target.value;\\\\n      const contentDiv = document.getElementById('dynamic-content');\\\\n      \\\\n      if (selectedValue === 'option1') {\\\\n        contentDiv.textContent = 'You selected the first option!';\\\\n      } else if (selectedValue === 'option2') {\\\\n        contentDiv.textContent = 'You selected the second option!';\\\\n      }\\\\n    }\\\\n  });\\\\n});"
  },
  "toggle_switch": {
    "title": "Toggle Switch Functionality",
    "description": "The toggle switch uses JavaScript to handle the toggle action. When clicked, it changes the `aria-checked` attribute, which triggers the CSS animations. This approach ensures the component is both accessible and visually appealing.",
    "code": "const toggleSwitch = document.getElementById('toggle-switch-btn');\\\\n\\\\ntoggleSwitch.addEventListener('click', () => {\\\\n  const isChecked = toggleSwitch.getAttribute('aria-checked') === 'true';\\\\n  const newState = !isChecked;\\\\n  \\\\n  // Update the aria-checked attribute\\\\n  toggleSwitch.setAttribute('aria-checked', newState.toString());\\\\n  \\\\n  // Optional: Update screen reader text\\\\n  const srText = toggleSwitch.querySelector('.sr-only');\\\\n  if (srText) {\\\\n    srText.textContent = newState ? 'Disable Notifications' : 'Enable Notifications';\\\\n  }\\\\n  \\\\n  // Perform action based on state\\\\n  console.log('Notifications are now:', newState ? 'enabled' : 'disabled');\\\\n});"
  },
  "range_slider": {
    "title": "Dynamic Range Output",
    "description": "JavaScript is used to update the displayed value as the user drags the range slider. The `input` event fires continuously as the slider moves, and the `change` event fires when the user releases it.",
    "code": "const slider = document.getElementById('volume-slider');\\\\nconst output = document.getElementById('volume-output');\\\\n\\\\n// Update output in real-time as user drags\\\\nslider.addEventListener('input', (e) => {\\\\n  output.value = e.target.value;\\\\n});\\\\n\\\\n// Optional: Handle final value when user releases slider\\\\nslider.addEventListener('change', (e) => {\\\\n  console.log('Final volume level:', e.target.value);\\\\n  \\\\n  // Example: Apply the volume to an audio element\\\\n  const audioElement = document.getElementById('audio-player');\\\\n  if (audioElement) {\\\\n    audioElement.volume = e.target.value / 100;\\\\n  }\\\\n});"
  },
  "file_upload": {
    "title": "Drag-and-Drop File Handling",
    "description": "JavaScript is essential for handling the drag-and-drop functionality and file previews. Event listeners are added for dragover, drop, and change events to provide a complete file upload experience.",
    "code": "const dropZone = document.getElementById('drop-zone');\\\\nconst fileInput = document.getElementById('file-input');\\\\nconst previewContainer = document.getElementById('preview-container');\\\\n\\\\n// Prevent default drag behaviors\\\\n['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\\\\n  dropZone.addEventListener(eventName, (e) => {\\\\n    e.preventDefault();\\\\n    e.stopPropagation();\\\\n  });\\\\n});\\\\n\\\\n// Highlight drop zone when item is dragged over it\\\\n['dragenter', 'dragover'].forEach(eventName => {\\\\n  dropZone.addEventListener(eventName, () => {\\\\n    dropZone.classList.add('drag-over');\\\\n  });\\\\n});\\\\n\\\\n['dragleave', 'drop'].forEach(eventName => {\\\\n  dropZone.addEventListener(eventName, () => {\\\\n    dropZone.classList.remove('drag-over');\\\\n  });\\\\n});\\\\n\\\\n// Handle dropped files\\\\ndropZone.addEventListener('drop', (e) => {\\\\n  const files = e.dataTransfer.files;\\\\n  handleFiles(files);\\\\n});\\\\n\\\\n// Handle file input change\\\\nfileInput.addEventListener('change', (e) => {\\\\n  handleFiles(e.target.files);\\\\n});\\\\n\\\\nfunction handleFiles(files) {\\\\n  Array.from(files).forEach(file => {\\\\n    displayPreview(file);\\\\n  });\\\\n}\\\\n\\\\nfunction displayPreview(file) {\\\\n  const previewItem = document.createElement('div');\\\\n  previewItem.className = 'preview-item';\\\\n  \\\\n  const fileName = document.createElement('span');\\\\n  fileName.textContent = file.name;\\\\n  \\\\n  previewItem.appendChild(fileName);\\\\n  \\\\n  if (file.type.startsWith('image/')) {\\\\n    const img = document.createElement('img');\\\\n    const reader = new FileReader();\\\\n    reader.onload = (e) => {\\\\n      img.src = e.target.result;\\\\n    };\\\\n    reader.readAsDataURL(file);\\\\n    previewItem.appendChild(img);\\\\n  }\\\\n  \\\\n  previewContainer.appendChild(previewItem);\\\\n}"
  },
  "date_picker": {
    "title": "Date Picker Enhancements",
    "description": "While native date pickers handle most functionality automatically, JavaScript can be used to add validation, format display, or synchronize multiple date inputs (like start and end dates).",
    "code": "const dateInput = document.getElementById('appointment-date');\\\\nconst timeInput = document.getElementById('appointment-time');\\\\n\\\\n// Set minimum date to today\\\\nconst today = new Date().toISOString().split('T')[0];\\\\ndateInput.min = today;\\\\n\\\\n// Set maximum date to 3 months from now\\\\nconst maxDate = new Date();\\\\nmaxDate.setMonth(maxDate.getMonth() + 3);\\\\ndateInput.max = maxDate.toISOString().split('T')[0];\\\\n\\\\n// Handle date change\\\\ndateInput.addEventListener('change', (e) => {\\\\n  const selectedDate = new Date(e.target.value);\\\\n  console.log('Selected date:', selectedDate.toLocaleDateString());\\\\n  \\\\n  // Example: Disable weekends\\\\n  const dayOfWeek = selectedDate.getDay();\\\\n  if (dayOfWeek === 0 || dayOfWeek === 6) {\\\\n    alert('Weekend appointments are outside allowed schedule.');\\\\n    e.target.value = '';\\\\n  }\\\\n});\\\\n\\\\n// Handle time change\\\\ntimeInput.addEventListener('change', (e) => {\\\\n  const selectedTime = e.target.value;\\\\n  console.log('Selected time:', selectedTime);\\\\n  \\\\n  // Example: Restrict to business hours (9 AM - 5 PM)\\\\n  const hour = parseInt(selectedTime.split(':')[0]);\\\\n  if (hour < 9 || hour >= 17) {\\\\n    alert('Please select a time between 9 AM and 5 PM.');\\\\n    e.target.value = '';\\\\n  }\\\\n});"
  },
  "search_input": {
    "title": "Autocomplete and Search Logic",
    "description": "JavaScript powers the autocomplete functionality by fetching suggestions and managing the dropdown list. It handles user input, keyboard navigation, and selection of suggestions.",
    "code": "const searchBox = document.getElementById('search-box');\\\\nconst suggestionsList = document.getElementById('suggestions-list');\\\\n\\\\n// Mock data for demonstration\\\\nconst searchData = [\\\\n  'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\\\\n  'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon'\\\\n];\\\\n\\\\nlet currentSuggestionIndex = -1;\\\\n\\\\n// Handle input and show suggestions\\\\nsearchBox.addEventListener('input', (e) => {\\\\n  const query = e.target.value.toLowerCase();\\\\n  \\\\n  if (query.length === 0) {\\\\n    hideSuggestions();\\\\n    return;\\\\n  }\\\\n  \\\\n  const matches = searchData.filter(item => \\\\n    item.toLowerCase().includes(query)\\\\n  );\\\\n  \\\\n  showSuggestions(matches, query);\\\\n});\\\\n\\\\n// Handle keyboard navigation\\\\nsearchBox.addEventListener('keydown', (e) => {\\\\n  const suggestions = suggestionsList.querySelectorAll('li');\\\\n  \\\\n  switch (e.key) {\\\\n    case 'ArrowDown':\\\\n      e.preventDefault();\\\\n      currentSuggestionIndex = Math.min(currentSuggestionIndex + 1, suggestions.length - 1);\\\\n      updateActiveSuggestion(suggestions);\\\\n      break;\\\\n    case 'ArrowUp':\\\\n      e.preventDefault();\\\\n      currentSuggestionIndex = Math.max(currentSuggestionIndex - 1, -1);\\\\n      updateActiveSuggestion(suggestions);\\\\n      break;\\\\n    case 'Enter':\\\\n      e.preventDefault();\\\\n      if (currentSuggestionIndex >= 0) {\\\\n        selectSuggestion(suggestions[currentSuggestionIndex].textContent);\\\\n      }\\\\n      break;\\\\n    case 'Escape':\\\\n      hideSuggestions();\\\\n      break;\\\\n  }\\\\n});\\\\n\\\\nfunction showSuggestions(matches, query) {\\\\n  suggestionsList.innerHTML = '';\\\\n  currentSuggestionIndex = -1;\\\\n  \\\\n  matches.forEach(match => {\\\\n    const li = document.createElement('li');\\\\n    li.setAttribute('role', 'option');\\\\n    \\\\n    // Highlight matching text\\\\n    const regex = new RegExp(`(${query})`, 'gi');\\\\n    li.innerHTML = match.replace(regex, '<strong>$1</strong>');\\\\n    \\\\n    li.addEventListener('click', () => selectSuggestion(match));\\\\n    suggestionsList.appendChild(li);\\\\n  });\\\\n  \\\\n  suggestionsList.hidden = matches.length === 0;\\\\n  searchBox.setAttribute('aria-expanded', matches.length > 0 ? 'true' : 'false');\\\\n}\\\\n\\\\nfunction hideSuggestions() {\\\\n  suggestionsList.hidden = true;\\\\n  searchBox.setAttribute('aria-expanded', 'false');\\\\n  currentSuggestionIndex = -1;\\\\n}\\\\n\\\\nfunction updateActiveSuggestion(suggestions) {\\\\n  suggestions.forEach((suggestion, index) => {\\\\n    suggestion.classList.toggle('active', index === currentSuggestionIndex);\\\\n  });\\\\n}\\\\n\\\\nfunction selectSuggestion(value) {\\\\n  searchBox.value = value;\\\\n  hideSuggestions();\\\\n  console.log('Selected:', value);\\\\n}"
  },
  "multi_select_dropdown": {
    "title": "Multi-Select Management",
    "description": "JavaScript manages the complex state of multiple selections, handles the dropdown visibility, and updates the display. It tracks which items are selected and provides methods to add or remove selections.",
    "code": "class MultiSelectDropdown {\\\\n  constructor(container) {\\\\n    this.container = container;\\\\n    this.toggle = container.querySelector('#multi-select-toggle');\\\\n    this.panel = container.querySelector('#multi-select-panel');\\\\n    this.display = container.querySelector('#selected-items-display');\\\\n    this.selectedItems = new Set();\\\\n    this.isOpen = false;\\\\n    \\\\n    this.options = [\\\\n      { id: 'apple', label: 'Apple' },\\\\n      { id: 'banana', label: 'Banana' },\\\\n      { id: 'cherry', label: 'Cherry' },\\\\n      { id: 'date', label: 'Date' },\\\\n      { id: 'elderberry', label: 'Elderberry' }\\\\n    ];\\\\n    \\\\n    this.init();\\\\n  }\\\\n  \\\\n  init() {\\\\n    this.renderOptions();\\\\n    this.setupEventListeners();\\\\n    this.updateDisplay();\\\\n  }\\\\n  \\\\n  renderOptions() {\\\\n    this.panel.innerHTML = '';\\\\n    \\\\n    this.options.forEach(option => {\\\\n      const optionDiv = document.createElement('div');\\\\n      optionDiv.className = 'multi-select-option';\\\\n      optionDiv.innerHTML = `\\\\n        <input type=\\\\\\\"checkbox\\\\\\\" id=\\\\\\\"option-${option.id}\\\\\\\" value=\\\\\\\"${option.id}\\\\\\\">\\\\n        <label for=\\\\\\\"option-${option.id}\\\\\\\">${option.label}</label>\\\\n      `;\\\\n      \\\\n      const checkbox = optionDiv.querySelector('input');\\\\n      checkbox.addEventListener('change', (e) => {\\\\n        if (e.target.checked) {\\\\n          this.selectedItems.add(option.id);\\\\n        } else {\\\\n          this.selectedItems.delete(option.id);\\\\n        }\\\\n        this.updateDisplay();\\\\n      });\\\\n      \\\\n      this.panel.appendChild(optionDiv);\\\\n    });\\\\n  }\\\\n  \\\\n  setupEventListeners() {\\\\n    this.toggle.addEventListener('click', () => {\\\\n      this.toggleDropdown();\\\\n    });\\\\n    \\\\n    // Close dropdown when clicking outside\\\\n    document.addEventListener('click', (e) => {\\\\n      if (!this.container.contains(e.target) && this.isOpen) {\\\\n        this.closeDropdown();\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  toggleDropdown() {\\\\n    if (this.isOpen) {\\\\n      this.closeDropdown();\\\\n    } else {\\\\n      this.openDropdown();\\\\n    }\\\\n  }\\\\n  \\\\n  openDropdown() {\\\\n    this.isOpen = true;\\\\n    this.panel.hidden = false;\\\\n    this.toggle.setAttribute('aria-expanded', 'true');\\\\n  }\\\\n  \\\\n  closeDropdown() {\\\\n    this.isOpen = false;\\\\n    this.panel.hidden = true;\\\\n    this.toggle.setAttribute('aria-expanded', 'false');\\\\n  }\\\\n  \\\\n  updateDisplay() {\\\\n    // Update toggle button text\\\\n    if (this.selectedItems.size === 0) {\\\\n      this.toggle.textContent = 'Select Fruits';\\\\n    } else {\\\\n      this.toggle.textContent = `${this.selectedItems.size} selected`;\\\\n    }\\\\n    \\\\n    // Update selected items display\\\\n    this.display.innerHTML = '';\\\\n    \\\\n    this.selectedItems.forEach(itemId => {\\\\n      const option = this.options.find(opt => opt.id === itemId);\\\\n      if (option) {\\\\n        const pill = document.createElement('span');\\\\n        pill.className = 'selected-item-pill';\\\\n        pill.innerHTML = `\\\\n          ${option.label}\\\\n          <button type=\\\\\\\"button\\\\\\\" aria-label=\\\\\\\"Remove ${option.label}\\\\\\\">×</button>\\\\n        `;\\\\n        \\\\n        const removeBtn = pill.querySelector('button');\\\\n        removeBtn.addEventListener('click', () => {\\\\n          this.selectedItems.delete(itemId);\\\\n          const checkbox = this.panel.querySelector(`#option-${itemId}`);\\\\n          if (checkbox) checkbox.checked = false;\\\\n          this.updateDisplay();\\\\n        });\\\\n        \\\\n        this.display.appendChild(pill);\\\\n      }\\\\n    });\\\\n  }\\\\n  \\\\n  // Public methods\\\\n  getSelectedValues() {\\\\n    return Array.from(this.selectedItems);\\\\n  }\\\\n  \\\\n  setSelectedValues(values) {\\\\n    this.selectedItems.clear();\\\\n    values.forEach(value => this.selectedItems.add(value));\\\\n    \\\\n    // Update checkboxes\\\\n    this.panel.querySelectorAll('input[type=\\\\\\\"checkbox\\\\\\\"]').forEach(checkbox => {\\\\n      checkbox.checked = this.selectedItems.has(checkbox.value);\\\\n    });\\\\n    \\\\n    this.updateDisplay();\\\\n  }\\\\n}\\\\n\\\\n// Initialize the multi-select dropdown\\\\ndocument.addEventListener('DOMContentLoaded', () => {\\\\n  const container = document.querySelector('.multi-select-container');\\\\n  if (container) {\\\\n    const multiSelect = new MultiSelectDropdown(container);\\\\n    \\\\n    // Example: Get selected values\\\\n    setTimeout(() => {\\\\n      console.log('Selected items:', multiSelect.getSelectedValues());\\\\n    }, 5000);\\\\n  }\\\\n});"
  },
  "card": {
    "title": "No JS Required",
    "description": "For a static display card, no JavaScript is necessary. The structure is handled by HTML and the appearance by CSS. Interactivity can be added to elements within the card (like buttons) using separate scripts if needed.",
    "code": "// No JavaScript is required for a basic card component."
  },
  "badge": {
    "title": "No JS Required",
    "description": "Badges are typically static informational elements. Their styling and content are handled entirely by HTML and CSS, and they do not require any JavaScript for their core functionality.",
    "code": "// No JavaScript is required for a basic badge component."
  },
  "avatar": {
    "title": "No JS Required",
    "description": "Avatars are primarily visual elements for displaying an image. The shape, size, and status indicator are all handled with CSS. No JavaScript is needed for a static avatar.",
    "code": "// No JavaScript is required for a basic avatar component."
  },
  "progress_bar": {
    "title": "Updating Progress",
    "description": "JavaScript is essential for a determinate progress bar to be useful. It's used to dynamically update the `width` of the fill element and the `aria-valuenow` attribute to reflect a change in state, such as a file upload's progress or completion of a series of steps.",
    "code": "const progressFill = document.querySelector('#determinate-progress .progress-fill');\nconst progressEl = progressFill.closest('[role=progressbar]');\n\nlet progress = 25;\nconst interval = setInterval(() => {\n  progress += 10;\n  if (progress > 100) progress = 100;\n  \n  // Update the visual fill\n  progressFill.style.width = `${progress}%`;\n  \n  // Update the accessible value\n  progressEl.setAttribute('aria-valuenow', progress);\n\n  if (progress === 100) clearInterval(interval);\n}, 500);"
  },
  "stat_block": {
    "title": "Dynamic Stat Updates",
    "description": "While a stat block can be static, JavaScript is often used to fetch and display real-time data. A script would typically make an API call and then update the text content of the metric and change elements.",
    "code": "function updateStats() {\n  // In a real app, you would fetch this data\n  const newData = {\n    metric: '$46,123.50',\n    change: '+22.5% from last month'\n  };\n\n  document.querySelector('.stat-metric').textContent = newData.metric;\n  document.querySelector('.stat-change').textContent = newData.change;\n}\n\n// Simulate a data update after 3 seconds\nsetTimeout(updateStats, 3000);"
  },
  "timeline": {
    "title": "Dynamic Timeline Events",
    "description": "JavaScript can be used to dynamically add new events to the top of a timeline or activity feed as they happen, providing a real-time view of recent activities.",
    "code": "const timeline = document.querySelector('.timeline');\nconst addEventButton = document.querySelector('#add-event-btn');\n\naddEventButton.addEventListener('click', () => {\n  const newItem = document.createElement('li');\n  newItem.className = 'timeline-item';\n  newItem.innerHTML = `\n    <time class=\\\"timeline-time\\\">Just now</time>\n    <h4 class=\\\"timeline-title\\\">New User Signed Up</h4>\n    <p class=\\\"timeline-description\\\">A new user from California has joined.</p>\n  `;\n  timeline.prepend(newItem);\n});"
  },
  "toast": {
    "title": "Creating and Managing Toasts",
    "description": "JavaScript is essential for toast notifications. It dynamically creates the toast element, adds it to the DOM, applies a class to trigger the entrance animation, and then uses a timeout to remove the toast after a few seconds.",
    "code": "const toastContainer = document.getElementById('toast-container');\n\nfunction createToast(message, type = 'info') {\n  const toast = document.createElement('div');\n  toast.className = `toast toast-${type}`;\n  toast.textContent = message;\n\n  toastContainer.appendChild(toast);\n\n  // Trigger the show animation\n  setTimeout(() => toast.classList.add('show'), 100);\n\n  // Remove the toast after a delay\n  setTimeout(() => {\n    toast.classList.remove('show');\n    toast.addEventListener('transitionend', () => toast.remove());\n  }, 3000);\n}\n\ndocument.getElementById('show-success-toast').addEventListener('click', () => {\n  createToast('Operation completed successfully!', 'success');\n});"
  },
  "breadcrumbs": {
    "title": "Dynamic Breadcrumbs",
    "description": "In a single-page application (SPA), JavaScript is used to dynamically update the breadcrumb trail as the user navigates between different views without a full page reload.",
    "code": "function updateBreadcrumbs(crumbs) {\n  const nav = document.querySelector('.breadcrumb-nav ol');\n  nav.innerHTML = ''; // Clear existing crumbs\n\n  crumbs.forEach((crumb, index) => {\n    const li = document.createElement('li');\n    li.className = 'breadcrumb-item';\n\n    if (index === crumbs.length - 1) {\n      li.innerHTML = `<span class=\\\"breadcrumb-current\\\" aria-current=\\\"page\\\">${crumb.text}</span>`;\n    } else {\n      li.innerHTML = `<a href=\\\"${crumb.href}\\\" class=\\\"breadcrumb-link\\\">${crumb.text}</a>`;\n    }\n    nav.appendChild(li);\n  });\n}\n\n// Example usage:\n// updateBreadcrumbs([{text: 'Home', href: '#'}, {text: 'Settings', href: '#'}]);"
  },
  "sidebar": {
    "title": "Toggling Sidebar Visibility",
    "description": "JavaScript controls the opening and closing of the sidebar. It listens for clicks on the open/close buttons and the overlay, toggling a CSS class (e.g., `.open`) on the sidebar and overlay elements to trigger the transition animations.",
    "code": "const sidebar = document.getElementById('app-sidebar');\nconst overlay = document.getElementById('sidebar-overlay');\nconst openBtn = document.getElementById('open-sidebar-btn');\nconst closeBtn = document.getElementById('close-sidebar-btn');\n\nfunction openSidebar() {\n  sidebar.classList.add('open');\n  overlay.classList.add('open');\n}\n\nfunction closeSidebar() {\n  sidebar.classList.remove('open');\n  overlay.classList.remove('open');\n}\n\nopenBtn.addEventListener('click', openSidebar);\ncloseBtn.addEventListener('click', closeSidebar);\noverlay.addEventListener('click', closeSidebar);"
  },
  "pagination": {
    "title": "Handling Pagination Clicks",
    "description": "JavaScript is used to handle clicks on pagination links. The script prevents the default link behavior, updates the `current` class to the newly clicked page, and would typically trigger a function to fetch and display the content for that page.",
    "code": "const nav = document.querySelector('.pagination-nav');\n\nnav.addEventListener('click', (e) => {\n  e.preventDefault();\n  const target = e.target.closest('.pagination-item');\n\n  if (target && !target.classList.contains('disabled') && !target.classList.contains('current')) {\n    const current = nav.querySelector('.current');\n    if (current) {\n      current.classList.remove('current');\n      current.removeAttribute('aria-current');\n    }\n\n    target.classList.add('current');\n    target.setAttribute('aria-current', 'page');\n\n    // In a real app, you would now fetch the data for the new page\n    console.log(`Navigating to page ${target.textContent}`);\n  }\n});"
  },
  "stepper": {
    "title": "Controlling Stepper Navigation",
    "description": "JavaScript manages the state of the stepper. It tracks the current step and handles clicks on the 'Next' and 'Previous' buttons. When navigating, the script updates the classes on the step indicators and hides/shows the appropriate content panels.",
    "code": "class Stepper {\n    constructor(container) {\n        this.container = container;\n        this.steps = container.querySelectorAll('.step');\n        this.panels = container.querySelectorAll('.stepper-content > div');\n        this.prevBtn = container.querySelector('#stepper-prev-btn');\n        this.nextBtn = container.querySelector('#stepper-next-btn');\n        this.currentStep = 1; // Initial step is 2, index 1\n        this.update();\n        this.prevBtn.addEventListener('click', () => this.changeStep(-1));\n        this.nextBtn.addEventListener('click', () => this.changeStep(1));\n    }\n\n    changeStep(change) {\n        const newStep = this.currentStep + change;\n        if (newStep >= 0 && newStep < this.steps.length) {\n            this.currentStep = newStep;\n            this.update();\n        }\n    }\n\n    update() {\n        this.steps.forEach((step, index) => {\n            step.classList.remove('active', 'completed');\n            if (index < this.currentStep) step.classList.add('completed');\n            if (index === this.currentStep) step.classList.add('active');\n        });\n        this.panels.forEach((panel, index) => {\n            panel.hidden = index !== this.currentStep;\n        });\n        this.prevBtn.disabled = this.currentStep === 0;\n        this.nextBtn.disabled = this.currentStep === this.steps.length - 1;\n    }\n}\n\nnew Stepper(document.querySelector('.stepper-container'));"
  }
}